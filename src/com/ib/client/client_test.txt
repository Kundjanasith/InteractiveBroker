/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/AnyWrapper.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public interface AnyWrapper {
    void error( Exception e);
    void error( String str);
    void error(int id, int errorCode, String errorMsg);
    void connectionClosed();
}

/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/AnyWrapperMsgGenerator.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class AnyWrapperMsgGenerator {
    public static String error( Exception ex) { return "Error - " + ex;}
    public static String error( String str) { return str;}

	public static String error(int id, int errorCode, String errorMsg) {
		String err = Integer.toString(id);
        err += " | ";
        err += Integer.toString(errorCode);
        err += " | ";
        err += errorMsg;
        return err;
	}

	public static String connectionClosed() {
		return "Connection Closed";
	}
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/Builder.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

/** This class is used to build messages so the entire message can be
 *  sent to the socket in a single write. */
public class Builder {
	private static final char SEP = 0;

	private StringBuilder m_sb = new StringBuilder( 4096);

	public void send(int a) {
		send( a == Integer.MAX_VALUE ? "" : String.valueOf( a) );
	}

	public void send(double a) {
		send( a == Double.MAX_VALUE ? "" : String.valueOf( a) );
	}

	public void send( boolean a) {
		send( a ? 1 : 0);
	}

	public void send( IApiEnum a) {
		send( a.getApiString() );
	}

	public void send( String a) {
		if (a != null) {
			m_sb.append( a);
		}
		m_sb.append( SEP);
	}

	public String toString() {
		return m_sb.toString();
	}

	public byte[] getBytes() {
		return m_sb.toString().getBytes();
	}
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/ComboLeg.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class ComboLeg {
    public final static int 	SAME = 0; 	// open/close leg value is same as combo
    public final static int 	OPEN = 1;
    public final static int 	CLOSE = 2;
    public final static int 	UNKNOWN = 3;

    public int 					m_conId;
    public int 					m_ratio;
    public String 				m_action; // BUY/SELL/SSHORT/SSHORTX
    public String 				m_exchange;
    public int 					m_openClose;

    // for stock legs when doing short sale
    public int                  m_shortSaleSlot; // 1 = clearing broker, 2 = third party
    public String               m_designatedLocation;
    public int                  m_exemptCode;

    public ComboLeg() {
    	this(/* conId */ 0, /* ratio */ 0, /* action */ null,
    		/* exchange */ null, /* openClose */ 0,
    		/* shortSaleSlot */ 0, /* designatedLocation*/ null, /* exemptCode */ -1);
    }

    public ComboLeg(int p_conId, int p_ratio, String p_action, String p_exchange, int p_openClose) {
    	this(p_conId, p_ratio, p_action, p_exchange, p_openClose,
    		/* shortSaleSlot */ 0, /* designatedLocation*/ null, /* exemptCode */ -1);

    }

    public ComboLeg(int p_conId, int p_ratio, String p_action, String p_exchange,
    		int p_openClose, int p_shortSaleSlot, String p_designatedLocation) {
    	this(p_conId, p_ratio, p_action, p_exchange, p_openClose, p_shortSaleSlot, p_designatedLocation,
    		/* exemptCode */ -1);

    }

    public ComboLeg(int p_conId, int p_ratio, String p_action, String p_exchange,
    		int p_openClose, int p_shortSaleSlot, String p_designatedLocation, int p_exemptCode) {
        m_conId = p_conId;
        m_ratio = p_ratio;
        m_action = p_action;
        m_exchange = p_exchange;
        m_openClose = p_openClose;
        m_shortSaleSlot = p_shortSaleSlot;
        m_designatedLocation = p_designatedLocation;
        m_exemptCode = p_exemptCode;
    }

    public boolean equals(Object p_other) {
        if ( this == p_other ) {
            return true;
        }
        else if ( p_other == null ) {
            return false;
        }

        ComboLeg l_theOther = (ComboLeg)p_other;

        if (m_conId != l_theOther.m_conId ||
        	m_ratio != l_theOther.m_ratio ||
        	m_openClose != l_theOther.m_openClose ||
        	m_shortSaleSlot != l_theOther.m_shortSaleSlot ||
        	m_exemptCode != l_theOther.m_exemptCode) {
        	return false;
        }

        if (Util.StringCompareIgnCase(m_action, l_theOther.m_action) != 0 ||
        	Util.StringCompareIgnCase(m_exchange, l_theOther.m_exchange) != 0 ||
        	Util.StringCompareIgnCase(m_designatedLocation, l_theOther.m_designatedLocation) != 0) {
        	return false;
        }

        return true;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/CommissionReport.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class CommissionReport {

    public String m_execId;
    public double m_commission;
    public String m_currency;
    public double m_realizedPNL;
    public double m_yield;
    public int    m_yieldRedemptionDate; // YYYYMMDD format

    public CommissionReport() {
        m_commission = 0;
        m_realizedPNL = 0;
        m_yield = 0;
        m_yieldRedemptionDate = 0;
    }

    public boolean equals(Object p_other) {
        boolean l_bRetVal = false;

        if ( p_other == null ) {
            l_bRetVal = false;
        }
        else if ( this == p_other ) {
            l_bRetVal = true;
        }
        else {
            CommissionReport l_theOther = (CommissionReport)p_other;
            l_bRetVal = m_execId.equals( l_theOther.m_execId);
        }
        return l_bRetVal;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/Contract.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.util.Vector;

public class Contract implements Cloneable {

	public int    m_conId;
    public String m_symbol;
    public String m_secType;
    public String m_expiry;
    public double m_strike;
    public String m_right;
    public String m_multiplier;
    public String m_exchange;

    public String m_currency;
    public String m_localSymbol;
    public String m_tradingClass;
    public String m_primaryExch;      // pick a non-aggregate (ie not the SMART exchange) exchange that the contract trades on.  DO NOT SET TO SMART.
    public boolean m_includeExpired;  // can not be set to true for orders.

    public String m_secIdType;        // CUSIP;SEDOL;ISIN;RIC
    public String m_secId;

    // COMBOS
    public String m_comboLegsDescrip; // received in open order version 14 and up for all combos
    public Vector<ComboLeg> m_comboLegs = new Vector<ComboLeg>();

    // delta neutral
    public UnderComp m_underComp;

    public Contract() {
    	m_conId = 0;
        m_strike = 0;
        m_includeExpired = false;
    }

    public Object clone() throws CloneNotSupportedException {
        Contract retval = (Contract)super.clone();
        retval.m_comboLegs = (Vector<ComboLeg>)retval.m_comboLegs.clone();
        return retval;
    }

    public Contract(int p_conId, String p_symbol, String p_secType, String p_expiry,
                    double p_strike, String p_right, String p_multiplier,
                    String p_exchange, String p_currency, String p_localSymbol, String p_tradingClass,
                    Vector<ComboLeg> p_comboLegs, String p_primaryExch, boolean p_includeExpired,
                    String p_secIdType, String p_secId) {
    	m_conId = p_conId;
        m_symbol = p_symbol;
        m_secType = p_secType;
        m_expiry = p_expiry;
        m_strike = p_strike;
        m_right = p_right;
        m_multiplier = p_multiplier;
        m_exchange = p_exchange;
        m_currency = p_currency;
        m_includeExpired = p_includeExpired;
        m_localSymbol = p_localSymbol;
        m_tradingClass = p_tradingClass;
        m_comboLegs = p_comboLegs;
        m_primaryExch = p_primaryExch;
        m_secIdType = p_secIdType;
        m_secId = p_secId ;
    }

    public boolean equals(Object p_other) {

    	if (this == p_other) {
    		return true;
    	}

    	if (p_other == null || !(p_other instanceof Contract)) {
    		return false;
    	}

        Contract l_theOther = (Contract)p_other;

        if (m_conId != l_theOther.m_conId) {
        	return false;
        }

        if (Util.StringCompare(m_secType, l_theOther.m_secType) != 0) {
        	return false;
        }

        if (Util.StringCompare(m_symbol, l_theOther.m_symbol) != 0 ||
        	Util.StringCompare(m_exchange, l_theOther.m_exchange) != 0 ||
        	Util.StringCompare(m_primaryExch, l_theOther.m_primaryExch) != 0 ||
        	Util.StringCompare(m_currency, l_theOther.m_currency) != 0) {
        	return false;
        }

        if (!Util.NormalizeString(m_secType).equals("BOND")) {

        	if (m_strike != l_theOther.m_strike) {
        		return false;
        	}

        	if (Util.StringCompare(m_expiry, l_theOther.m_expiry) != 0 ||
        		Util.StringCompare(m_right, l_theOther.m_right) != 0 ||
        		Util.StringCompare(m_multiplier, l_theOther.m_multiplier) != 0 ||
        		Util.StringCompare(m_localSymbol, l_theOther.m_localSymbol) != 0 ||
        		Util.StringCompare(m_tradingClass, l_theOther.m_tradingClass) != 0) {
        		return false;
        	}
        }

        if (Util.StringCompare(m_secIdType, l_theOther.m_secIdType) != 0) {
        	return false;
        }

        if (Util.StringCompare(m_secId, l_theOther.m_secId) != 0) {
        	return false;
        }

    	// compare combo legs
        if (!Util.VectorEqualsUnordered(m_comboLegs, l_theOther.m_comboLegs)) {
        	return false;
        }

        if (m_underComp != l_theOther.m_underComp) {
        	if (m_underComp == null || l_theOther.m_underComp == null) {
        		return false;
        	}
        	if (!m_underComp.equals(l_theOther.m_underComp)) {
        		return false;
        	}
        }

        return true;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/ContractDetails.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.util.Vector;

public class ContractDetails {
    public Contract	m_summary;
    public String 	m_marketName;
    public double 	m_minTick;
    public int      m_priceMagnifier;
    public String 	m_orderTypes;
    public String 	m_validExchanges;
    public int      m_underConId;
    public String 	m_longName;
    public String	m_contractMonth;
    public String	m_industry;
    public String	m_category;
    public String	m_subcategory;
    public String	m_timeZoneId;
    public String	m_tradingHours;
    public String	m_liquidHours;
    public String 	m_evRule;
    public double 	m_evMultiplier;

    public Vector<TagValue> m_secIdList; // CUSIP/ISIN/etc.

    // BOND values
    public String 	m_cusip;
    public String 	m_ratings;
    public String 	m_descAppend;
    public String 	m_bondType;
    public String 	m_couponType;
    public boolean 	m_callable			= false;
    public boolean 	m_putable			= false;
    public double 	m_coupon			= 0;
    public boolean 	m_convertible		= false;
    public String 	m_maturity;
    public String 	m_issueDate;
    public String 	m_nextOptionDate;
    public String 	m_nextOptionType;
    public boolean 	m_nextOptionPartial = false;
    public String 	m_notes;

    public ContractDetails() {
        m_summary = new Contract();
        m_minTick = 0;
        m_underConId = 0;
        m_evMultiplier = 0;
    }

    public ContractDetails( Contract p_summary, String p_marketName, 
    		double p_minTick, String p_orderTypes, String p_validExchanges, int p_underConId, String p_longName,
    	    String p_contractMonth, String p_industry, String p_category, String p_subcategory,
    	    String p_timeZoneId, String	p_tradingHours, String p_liquidHours,
    	    String p_evRule, double p_evMultiplier) {
        m_summary = p_summary;
    	m_marketName = p_marketName;
    	m_minTick = p_minTick;
    	m_orderTypes = p_orderTypes;
    	m_validExchanges = p_validExchanges;
    	m_underConId = p_underConId;
    	m_longName = p_longName;
        m_contractMonth = p_contractMonth;
        m_industry = p_industry;
        m_category = p_category;
        m_subcategory = p_subcategory;
        m_timeZoneId = p_timeZoneId;
        m_tradingHours = p_tradingHours;
        m_liquidHours = p_liquidHours;
        m_evRule = p_evRule;
        m_evMultiplier = p_evMultiplier;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/EClientErrors.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;


public class EClientErrors {
    public static final int NO_VALID_ID = -1;
    public static final CodeMsgPair NOT_CONNECTED = new CodeMsgPair(504, "Not connected");
    public static final CodeMsgPair UPDATE_TWS = new CodeMsgPair(503, "The TWS is out of date and must be upgraded.");
    static final CodeMsgPair ALREADY_CONNECTED = new CodeMsgPair(501, "Already connected.");
    static final CodeMsgPair CONNECT_FAIL = new CodeMsgPair(502, "Couldn't connect to TWS.  Confirm that \"Enable ActiveX and Socket Clients\" is enabled on the TWS \"Configure->API\" menu.");
    static final CodeMsgPair FAIL_SEND = new CodeMsgPair(509, "Failed to send message - "); // generic message; all future messages should use this
    static final CodeMsgPair UNKNOWN_ID = new CodeMsgPair(505, "Fatal Error: Unknown message id.");
    static final CodeMsgPair FAIL_SEND_REQMKT = new CodeMsgPair(510, "Request Market Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANMKT = new CodeMsgPair(511, "Cancel Market Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_ORDER = new CodeMsgPair(512, "Order Sending Error - ");
    static final CodeMsgPair FAIL_SEND_ACCT = new CodeMsgPair(513, "Account Update Request Sending Error -");
    static final CodeMsgPair FAIL_SEND_EXEC = new CodeMsgPair(514, "Request For Executions Sending Error -");
    static final CodeMsgPair FAIL_SEND_CORDER = new CodeMsgPair(515, "Cancel Order Sending Error -");
    static final CodeMsgPair FAIL_SEND_OORDER = new CodeMsgPair(516, "Request Open Order Sending Error -");
    static final CodeMsgPair UNKNOWN_CONTRACT = new CodeMsgPair(517, "Unknown contract. Verify the contract details supplied.");
    static final CodeMsgPair FAIL_SEND_REQCONTRACT = new CodeMsgPair(518, "Request Contract Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQMKTDEPTH = new CodeMsgPair(519, "Request Market Depth Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANMKTDEPTH = new CodeMsgPair(520, "Cancel Market Depth Sending Error - ");
    static final CodeMsgPair FAIL_SEND_SERVER_LOG_LEVEL = new CodeMsgPair(521, "Set Server Log Level Sending Error - ");
    static final CodeMsgPair FAIL_SEND_FA_REQUEST = new CodeMsgPair(522, "FA Information Request Sending Error - ");
    static final CodeMsgPair FAIL_SEND_FA_REPLACE = new CodeMsgPair(523, "FA Information Replace Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQSCANNER = new CodeMsgPair(524, "Request Scanner Subscription Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANSCANNER = new CodeMsgPair(525, "Cancel Scanner Subscription Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQSCANNERPARAMETERS = new CodeMsgPair(526, "Request Scanner Parameter Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQHISTDATA = new CodeMsgPair(527, "Request Historical Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANHISTDATA = new CodeMsgPair(528, "Request Historical Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQRTBARS = new CodeMsgPair(529, "Request Real-time Bar Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANRTBARS = new CodeMsgPair(530, "Cancel Real-time Bar Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQCURRTIME = new CodeMsgPair(531, "Request Current Time Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQFUNDDATA = new CodeMsgPair(532, "Request Fundamental Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANFUNDDATA = new CodeMsgPair(533, "Cancel Fundamental Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQCALCIMPLIEDVOLAT = new CodeMsgPair(534, "Request Calculate Implied Volatility Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQCALCOPTIONPRICE = new CodeMsgPair(535, "Request Calculate Option Price Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANCALCIMPLIEDVOLAT = new CodeMsgPair(536, "Cancel Calculate Implied Volatility Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANCALCOPTIONPRICE = new CodeMsgPair(537, "Cancel Calculate Option Price Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQGLOBALCANCEL = new CodeMsgPair(538, "Request Global Cancel Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQMARKETDATATYPE = new CodeMsgPair(539, "Request Market Data Type Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQPOSITIONS = new CodeMsgPair(540, "Request Positions Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANPOSITIONS = new CodeMsgPair(541, "Cancel Positions Sending Error - ");
    static final CodeMsgPair FAIL_SEND_REQACCOUNTDATA = new CodeMsgPair(542, "Request Account Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_CANACCOUNTDATA = new CodeMsgPair(543, "Cancel Account Data Sending Error - ");
    static final CodeMsgPair FAIL_SEND_VERIFYREQUEST = new CodeMsgPair(544, "Verify Request Sending Error - ");
    static final CodeMsgPair FAIL_SEND_VERIFYMESSAGE = new CodeMsgPair(545, "Verify Message Sending Error - ");
    static final CodeMsgPair FAIL_SEND_QUERYDISPLAYGROUPS = new CodeMsgPair(546, "Query Display Groups Sending Error - ");
    static final CodeMsgPair FAIL_SEND_SUBSCRIBETOGROUPEVENTS = new CodeMsgPair(547, "Subscribe To Group Events Sending Error - ");
    static final CodeMsgPair FAIL_SEND_UPDATEDISPLAYGROUP = new CodeMsgPair(548, "Update Display Group Sending Error - ");
    static final CodeMsgPair FAIL_SEND_UNSUBSCRIBEFROMGROUPEVENTS = new CodeMsgPair(549, "Unsubscribe From Group Events Sending Error - ");
    static final CodeMsgPair FAIL_SEND_STARTAPI = new CodeMsgPair(550, "Start API Sending Error - ");

    public EClientErrors() {
    }

    static public class CodeMsgPair {

        // members vars
        int m_errorCode;
        String m_errorMsg;

        // Get/Set methods
        public int code()    { return m_errorCode; }
        public String msg()  { return m_errorMsg; }

        /** Constructor */
        public CodeMsgPair(int i, String errString) {
            m_errorCode = i;
            m_errorMsg = errString;
        }
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/EClientSocket.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.util.List;
import java.util.Vector;

public class EClientSocket {

    // Client version history
    //
    // 	6 = Added parentId to orderStatus
    // 	7 = The new execDetails event returned for an order filled status and reqExecDetails
    //     Also market depth is available.
    // 	8 = Added lastFillPrice to orderStatus() event and permId to execution details
    //  9 = Added 'averageCost', 'unrealizedPNL', and 'unrealizedPNL' to updatePortfolio event
    // 10 = Added 'serverId' to the 'open order' & 'order status' events.
    //      We send back all the API open orders upon connection.
    //      Added new methods reqAllOpenOrders, reqAutoOpenOrders()
    //      Added FA support - reqExecution has filter.
    //                       - reqAccountUpdates takes acct code.
    // 11 = Added permId to openOrder event.
    // 12 = requsting open order attributes ignoreRth, hidden, and discretionary
    // 13 = added goodAfterTime
    // 14 = always send size on bid/ask/last tick
    // 15 = send allocation description string on openOrder
    // 16 = can receive account name in account and portfolio updates, and fa params in openOrder
    // 17 = can receive liquidation field in exec reports, and notAutoAvailable field in mkt data
    // 18 = can receive good till date field in open order messages, and request intraday backfill
    // 19 = can receive rthOnly flag in ORDER_STATUS
    // 20 = expects TWS time string on connection after server version >= 20.
    // 21 = can receive bond contract details.
    // 22 = can receive price magnifier in version 2 contract details message
    // 23 = support for scanner
    // 24 = can receive volatility order parameters in open order messages
	// 25 = can receive HMDS query start and end times
	// 26 = can receive option vols in option market data messages
	// 27 = can receive delta neutral order type and delta neutral aux price in place order version 20: API 8.85
	// 28 = can receive option model computation ticks: API 8.9
	// 29 = can receive trail stop limit price in open order and can place them: API 8.91
	// 30 = can receive extended bond contract def, new ticks, and trade count in bars
	// 31 = can receive EFP extensions to scanner and market data, and combo legs on open orders
	//    ; can receive RT bars
	// 32 = can receive TickType.LAST_TIMESTAMP
	//    ; can receive "whyHeld" in order status messages
	// 33 = can receive ScaleNumComponents and ScaleComponentSize is open order messages
	// 34 = can receive whatIf orders / order state
	// 35 = can receive contId field for Contract objects
	// 36 = can receive outsideRth field for Order objects
	// 37 = can receive clearingAccount and clearingIntent for Order objects
	// 38 = can receive multiplier and primaryExchange in portfolio updates
	//    ; can receive cumQty and avgPrice in execution
	//    ; can receive fundamental data
	//    ; can receive underComp for Contract objects
	//    ; can receive reqId and end marker in contractDetails/bondContractDetails
 	//    ; can receive ScaleInitComponentSize and ScaleSubsComponentSize for Order objects
	// 39 = can receive underConId in contractDetails
	// 40 = can receive algoStrategy/algoParams in openOrder
	// 41 = can receive end marker for openOrder
	//    ; can receive end marker for account download
	//    ; can receive end marker for executions download
	// 42 = can receive deltaNeutralValidation
	// 43 = can receive longName(companyName)
	//    ; can receive listingExchange
	//    ; can receive RTVolume tick
	// 44 = can receive end market for ticker snapshot
	// 45 = can receive notHeld field in openOrder
	// 46 = can receive contractMonth, industry, category, subcategory fields in contractDetails
	//    ; can receive timeZoneId, tradingHours, liquidHours fields in contractDetails
	// 47 = can receive gamma, vega, theta, undPrice fields in TICK_OPTION_COMPUTATION
	// 48 = can receive exemptCode in openOrder
	// 49 = can receive hedgeType and hedgeParam in openOrder
	// 50 = can receive optOutSmartRouting field in openOrder
	// 51 = can receive smartComboRoutingParams in openOrder
	// 52 = can receive deltaNeutralConId, deltaNeutralSettlingFirm, deltaNeutralClearingAccount and deltaNeutralClearingIntent in openOrder
	// 53 = can receive orderRef in execution
	// 54 = can receive scale order fields (PriceAdjustValue, PriceAdjustInterval, ProfitOffset, AutoReset,
	//      InitPosition, InitFillQty and RandomPercent) in openOrder
	// 55 = can receive orderComboLegs (price) in openOrder
	// 56 = can receive trailingPercent in openOrder
	// 57 = can receive commissionReport message
	// 58 = can receive CUSIP/ISIN/etc. in contractDescription/bondContractDescription
	// 59 = can receive evRule, evMultiplier in contractDescription/bondContractDescription/executionDetails
	//      can receive multiplier in executionDetails
	// 60 = can receive deltaNeutralOpenClose, deltaNeutralShortSale, deltaNeutralShortSaleSlot and deltaNeutralDesignatedLocation in openOrder
	// 61 = can receive multiplier in openOrder
	//      can receive tradingClass in openOrder, updatePortfolio, execDetails and position
	// 62 = can receive avgCost in position message
	// 63 = can receive verifyMessageAPI, verifyCompleted, displayGroupList and displayGroupUpdated messages

    private static final int CLIENT_VERSION = 63;
    private static final int SERVER_VERSION = 38;
    private static final byte[] EOL = {0};
    private static final String BAG_SEC_TYPE = "BAG";

    // FA msg data types
    public static final int GROUPS = 1;
    public static final int PROFILES = 2;
    public static final int ALIASES = 3;

    public static String faMsgTypeName(int faDataType) {
        switch (faDataType) {
            case GROUPS:
                return "GROUPS";
            case PROFILES:
                return "PROFILES";
            case ALIASES:
                return "ALIASES";
        }
        return null;
    }

    // outgoing msg id's
    private static final int REQ_MKT_DATA = 1;
    private static final int CANCEL_MKT_DATA = 2;
    protected static final int PLACE_ORDER = 3;
    private static final int CANCEL_ORDER = 4;
    private static final int REQ_OPEN_ORDERS = 5;
    private static final int REQ_ACCOUNT_DATA = 6;
    private static final int REQ_EXECUTIONS = 7;
    private static final int REQ_IDS = 8;
    private static final int REQ_CONTRACT_DATA = 9;
    private static final int REQ_MKT_DEPTH = 10;
    private static final int CANCEL_MKT_DEPTH = 11;
    private static final int REQ_NEWS_BULLETINS = 12;
    private static final int CANCEL_NEWS_BULLETINS = 13;
    private static final int SET_SERVER_LOGLEVEL = 14;
    private static final int REQ_AUTO_OPEN_ORDERS = 15;
    private static final int REQ_ALL_OPEN_ORDERS = 16;
    private static final int REQ_MANAGED_ACCTS = 17;
    private static final int REQ_FA = 18;
    private static final int REPLACE_FA = 19;
    private static final int REQ_HISTORICAL_DATA = 20;
    private static final int EXERCISE_OPTIONS = 21;
    private static final int REQ_SCANNER_SUBSCRIPTION = 22;
    private static final int CANCEL_SCANNER_SUBSCRIPTION = 23;
    private static final int REQ_SCANNER_PARAMETERS = 24;
    private static final int CANCEL_HISTORICAL_DATA = 25;
    private static final int REQ_CURRENT_TIME = 49;
    private static final int REQ_REAL_TIME_BARS = 50;
    private static final int CANCEL_REAL_TIME_BARS = 51;
    private static final int REQ_FUNDAMENTAL_DATA = 52;
    private static final int CANCEL_FUNDAMENTAL_DATA = 53;
    private static final int REQ_CALC_IMPLIED_VOLAT = 54;
    private static final int REQ_CALC_OPTION_PRICE = 55;
    private static final int CANCEL_CALC_IMPLIED_VOLAT = 56;
    private static final int CANCEL_CALC_OPTION_PRICE = 57;
    private static final int REQ_GLOBAL_CANCEL = 58;
    private static final int REQ_MARKET_DATA_TYPE = 59;
    private static final int REQ_POSITIONS = 61;
    private static final int REQ_ACCOUNT_SUMMARY = 62;
    private static final int CANCEL_ACCOUNT_SUMMARY = 63;
    private static final int CANCEL_POSITIONS = 64;
    private static final int VERIFY_REQUEST = 65;
    private static final int VERIFY_MESSAGE = 66;
    private static final int QUERY_DISPLAY_GROUPS = 67;
    private static final int SUBSCRIBE_TO_GROUP_EVENTS = 68;
    private static final int UPDATE_DISPLAY_GROUP = 69;
    private static final int UNSUBSCRIBE_FROM_GROUP_EVENTS = 70;
    private static final int START_API = 71;

	private static final int MIN_SERVER_VER_REAL_TIME_BARS = 34;
	private static final int MIN_SERVER_VER_SCALE_ORDERS = 35;
	private static final int MIN_SERVER_VER_SNAPSHOT_MKT_DATA = 35;
	private static final int MIN_SERVER_VER_SSHORT_COMBO_LEGS = 35;
	private static final int MIN_SERVER_VER_WHAT_IF_ORDERS = 36;
	private static final int MIN_SERVER_VER_CONTRACT_CONID = 37;
	private static final int MIN_SERVER_VER_PTA_ORDERS = 39;
	private static final int MIN_SERVER_VER_FUNDAMENTAL_DATA = 40;
	private static final int MIN_SERVER_VER_UNDER_COMP = 40;
	private static final int MIN_SERVER_VER_CONTRACT_DATA_CHAIN = 40;
	private static final int MIN_SERVER_VER_SCALE_ORDERS2 = 40;
	private static final int MIN_SERVER_VER_ALGO_ORDERS = 41;
	private static final int MIN_SERVER_VER_EXECUTION_DATA_CHAIN = 42;
	private static final int MIN_SERVER_VER_NOT_HELD = 44;
	private static final int MIN_SERVER_VER_SEC_ID_TYPE = 45;
	private static final int MIN_SERVER_VER_PLACE_ORDER_CONID = 46;
	private static final int MIN_SERVER_VER_REQ_MKT_DATA_CONID = 47;
    private static final int MIN_SERVER_VER_REQ_CALC_IMPLIED_VOLAT = 49;
    private static final int MIN_SERVER_VER_REQ_CALC_OPTION_PRICE = 50;
    private static final int MIN_SERVER_VER_CANCEL_CALC_IMPLIED_VOLAT = 50;
    private static final int MIN_SERVER_VER_CANCEL_CALC_OPTION_PRICE = 50;
    private static final int MIN_SERVER_VER_SSHORTX_OLD = 51;
    private static final int MIN_SERVER_VER_SSHORTX = 52;
    private static final int MIN_SERVER_VER_REQ_GLOBAL_CANCEL = 53;
    private static final int MIN_SERVER_VER_HEDGE_ORDERS = 54;
    private static final int MIN_SERVER_VER_REQ_MARKET_DATA_TYPE = 55;
    private static final int MIN_SERVER_VER_OPT_OUT_SMART_ROUTING = 56;
    private static final int MIN_SERVER_VER_SMART_COMBO_ROUTING_PARAMS = 57;
    private static final int MIN_SERVER_VER_DELTA_NEUTRAL_CONID = 58;
    private static final int MIN_SERVER_VER_SCALE_ORDERS3 = 60;
    private static final int MIN_SERVER_VER_ORDER_COMBO_LEGS_PRICE = 61;
    private static final int MIN_SERVER_VER_TRAILING_PERCENT = 62;
    protected static final int MIN_SERVER_VER_DELTA_NEUTRAL_OPEN_CLOSE = 66;
    private static final int MIN_SERVER_VER_ACCT_SUMMARY = 67;
    protected static final int MIN_SERVER_VER_TRADING_CLASS = 68;
    protected static final int MIN_SERVER_VER_SCALE_TABLE = 69;
    protected static final int MIN_SERVER_VER_LINKING = 70;

    private AnyWrapper m_anyWrapper;    // msg handler
    protected DataOutputStream m_dos;   // the socket output stream
    private boolean m_connected;        // true if we are connected
    private EReader m_reader;           // thread which reads msgs from socket
    protected int m_serverVersion;
    private String m_TwsTime;
    private int m_clientId;
    private boolean m_extraAuth;

    public int serverVersion()          { return m_serverVersion;   }
    public String TwsConnectionTime()   { return m_TwsTime; }
    public AnyWrapper wrapper() 		{ return m_anyWrapper; }
    public EReader reader()             { return m_reader; }
    public boolean isConnected() 		{ return m_connected; }

    protected synchronized void setExtraAuth(boolean extraAuth){
        m_extraAuth = extraAuth;
    }

    public EClientSocket( AnyWrapper anyWrapper) {
        m_anyWrapper = anyWrapper;
        m_clientId = -1;
        m_extraAuth = false;
        m_connected = false;
        m_serverVersion = 0;
    }
    
    public synchronized void eConnect( String host, int port, int clientId) {
        eConnect(host, port, clientId, false);
    }
    
    public synchronized void eConnect( String host, int port, int clientId, boolean extraAuth) {
        // already connected?
        host = checkConnected(host);

        m_clientId = clientId;
        m_extraAuth = extraAuth;

        if(host == null){
            return;
        }
        try{
            Socket socket = new Socket( host, port);
            eConnect(socket);
        }
        catch( Exception e) {
        	eDisconnect();
            connectionError();
        }
    }

    protected void connectionError() {
        m_anyWrapper.error( EClientErrors.NO_VALID_ID, EClientErrors.CONNECT_FAIL.code(),
                EClientErrors.CONNECT_FAIL.msg());
        m_reader = null;
    }

    protected String checkConnected(String host) {
        if( m_connected) {
            m_anyWrapper.error(EClientErrors.NO_VALID_ID, EClientErrors.ALREADY_CONNECTED.code(),
                    EClientErrors.ALREADY_CONNECTED.msg());
            return null;
        }
        if( isNull( host) ) {
            host = "127.0.0.1";
        }
        return host;
    }

    public EReader createReader(EClientSocket socket, DataInputStream dis) {
        return new EReader(socket, dis);
    }

    public synchronized void eConnect(Socket socket, int clientId) throws IOException {
        m_clientId = clientId;
        eConnect(socket);
    }
    
    public synchronized void eConnect(Socket socket) throws IOException {

        // create io streams
        m_dos = new DataOutputStream( socket.getOutputStream() );

        // set client version
        send( CLIENT_VERSION);

        // start reader thread
        m_reader = createReader(this, new DataInputStream(
        		socket.getInputStream()));

        // check server version
        m_serverVersion = m_reader.readInt();
        System.out.println("Server Version:" + m_serverVersion);
        if ( m_serverVersion >= 20 ){
            m_TwsTime = m_reader.readStr();
            System.out.println("TWS Time at connection:" + m_TwsTime);
        }
        if( m_serverVersion < SERVER_VERSION) {
        	eDisconnect();
            m_anyWrapper.error( EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(), EClientErrors.UPDATE_TWS.msg());
            return;
        }

        // set connected flag
        m_connected = true;

        // Send the client id
        if ( m_serverVersion >= 3 ){
            if ( m_serverVersion < MIN_SERVER_VER_LINKING) {
                send( m_clientId);
            }
            else if (!m_extraAuth){
                startAPI();
             }
        }

        m_reader.start();

    }

    public synchronized void eDisconnect() {
        // not connected?
        if( m_dos == null) {
            return;
        }

        m_connected = false;
        m_extraAuth = false;
        m_clientId = -1;
        m_serverVersion = 0;
        m_TwsTime = "";

        FilterOutputStream dos = m_dos;
        m_dos = null;

        EReader reader = m_reader;
        m_reader = null;

        try {
            // stop reader thread; reader thread will close input stream
            if( reader != null) {
                reader.interrupt();
            }
        }
        catch( Exception e) {
        }

        try {
            // close output stream
            if( dos != null) {
                dos.close();
            }
        }
        catch( Exception e) {
        }
    }

    protected synchronized void startAPI() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        try {
            send(START_API);
            send(VERSION);
            send(m_clientId);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID,
                   EClientErrors.FAIL_SEND_STARTAPI, "" + e);
            close();
        }
    }

    public synchronized void cancelScannerSubscription( int tickerId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < 24) {
          error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                "  It does not support API scanner subscription.");
          return;
        }

        final int VERSION = 1;

        // send cancel mkt data msg
        try {
            send( CANCEL_SCANNER_SUBSCRIPTION);
            send( VERSION);
            send( tickerId);
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_CANSCANNER, "" + e);
            close();
        }
    }

    public synchronized void reqScannerParameters() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < 24) {
          error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                "  It does not support API scanner subscription.");
          return;
        }

        final int VERSION = 1;

        try {
            send(REQ_SCANNER_PARAMETERS);
            send(VERSION);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID,
                   EClientErrors.FAIL_SEND_REQSCANNERPARAMETERS, "" + e);
            close();
        }
    }

    public synchronized void reqScannerSubscription( int tickerId, ScannerSubscription subscription, Vector<TagValue> scannerSubscriptionOptions) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < 24) {
          error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                "  It does not support API scanner subscription.");
          return;
        }

        final int VERSION = 4;

        try {
            send(REQ_SCANNER_SUBSCRIPTION);
            send(VERSION);
            send(tickerId);
            sendMax(subscription.numberOfRows());
            send(subscription.instrument());
            send(subscription.locationCode());
            send(subscription.scanCode());
            sendMax(subscription.abovePrice());
            sendMax(subscription.belowPrice());
            sendMax(subscription.aboveVolume());
            sendMax(subscription.marketCapAbove());
            sendMax(subscription.marketCapBelow());
            send(subscription.moodyRatingAbove());
            send(subscription.moodyRatingBelow());
            send(subscription.spRatingAbove());
            send(subscription.spRatingBelow());
            send(subscription.maturityDateAbove());
            send(subscription.maturityDateBelow());
            sendMax(subscription.couponRateAbove());
            sendMax(subscription.couponRateBelow());
            send(subscription.excludeConvertible());
            if (m_serverVersion >= 25) {
                sendMax(subscription.averageOptionVolumeAbove());
                send(subscription.scannerSettingPairs());
            }
            if (m_serverVersion >= 27) {
                send(subscription.stockTypeFilter());
            }
            
            // send scannerSubscriptionOptions parameter
            if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
                StringBuilder scannerSubscriptionOptionsStr = new StringBuilder();
                int scannerSubscriptionOptionsCount = scannerSubscriptionOptions == null ? 0 : scannerSubscriptionOptions.size();
                if( scannerSubscriptionOptionsCount > 0) {
                    for( int i = 0; i < scannerSubscriptionOptionsCount; ++i) {
                        TagValue tagValue = (TagValue)scannerSubscriptionOptions.get(i);
                        scannerSubscriptionOptionsStr.append( tagValue.m_tag);
                        scannerSubscriptionOptionsStr.append( "=");
                        scannerSubscriptionOptionsStr.append( tagValue.m_value);
                        scannerSubscriptionOptionsStr.append( ";");
                    }
                }
                send( scannerSubscriptionOptionsStr.toString());
            }
            
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_REQSCANNER, "" + e);
            close();
        }
    }

    public synchronized void reqMktData(int tickerId, Contract contract,
    		String genericTickList, boolean snapshot, List<TagValue> mktDataOptions) {
        if (!m_connected) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.NOT_CONNECTED, "");
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_SNAPSHOT_MKT_DATA && snapshot) {
        	error(tickerId, EClientErrors.UPDATE_TWS,
        			"  It does not support snapshot market data requests.");
        	return;
        }

        if (m_serverVersion < MIN_SERVER_VER_UNDER_COMP) {
        	if (contract.m_underComp != null) {
        		error(tickerId, EClientErrors.UPDATE_TWS,
        			"  It does not support delta-neutral orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_REQ_MKT_DATA_CONID) {
            if (contract.m_conId > 0) {
                error(tickerId, EClientErrors.UPDATE_TWS,
                    "  It does not support conId parameter.");
                return;
            }
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass)) {
                error(tickerId, EClientErrors.UPDATE_TWS,
                    "  It does not support tradingClass parameter in reqMarketData.");
                return;
            }
        }

        final int VERSION = 11;

        try {
            // send req mkt data msg
            send(REQ_MKT_DATA);
            send(VERSION);
            send(tickerId);

            // send contract fields
            if (m_serverVersion >= MIN_SERVER_VER_REQ_MKT_DATA_CONID) {
                send(contract.m_conId);
            }
            send(contract.m_symbol);
            send(contract.m_secType);
            send(contract.m_expiry);
            send(contract.m_strike);
            send(contract.m_right);
            if (m_serverVersion >= 15) {
                send(contract.m_multiplier);
            }
            send(contract.m_exchange);
            if (m_serverVersion >= 14) {
                send(contract.m_primaryExch);
            }
            send(contract.m_currency);
            if(m_serverVersion >= 2) {
                send( contract.m_localSymbol);
            }
            if(m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send( contract.m_tradingClass);
            }
            if(m_serverVersion >= 8 && BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
                if ( contract.m_comboLegs == null ) {
                    send( 0);
                }
                else {
                    send( contract.m_comboLegs.size());

                    ComboLeg comboLeg;
                    for (int i=0; i < contract.m_comboLegs.size(); i ++) {
                        comboLeg = contract.m_comboLegs.get(i);
                        send( comboLeg.m_conId);
                        send( comboLeg.m_ratio);
                        send( comboLeg.m_action);
                        send( comboLeg.m_exchange);
                    }
                }
            }

            if (m_serverVersion >= MIN_SERVER_VER_UNDER_COMP) {
         	   if (contract.m_underComp != null) {
         		   UnderComp underComp = contract.m_underComp;
         		   send( true);
         		   send( underComp.m_conId);
         		   send( underComp.m_delta);
         		   send( underComp.m_price);
         	   }
         	   else {
         		   send( false);
         	   }
            }

            if (m_serverVersion >= 31) {
            	/*
            	 * Note: Even though SHORTABLE tick type supported only
            	 *       starting server version 33 it would be relatively
            	 *       expensive to expose this restriction here.
            	 *
            	 *       Therefore we are relying on TWS doing validation.
            	 */
            	send( genericTickList);
            }
            if (m_serverVersion >= MIN_SERVER_VER_SNAPSHOT_MKT_DATA) {
            	send (snapshot);
            }
            
            // send mktDataOptions parameter
            if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
                StringBuilder mktDataOptionsStr = new StringBuilder();
                int mktDataOptionsCount = mktDataOptions == null ? 0 : mktDataOptions.size();
                if( mktDataOptionsCount > 0) {
                    for( int i = 0; i < mktDataOptionsCount; ++i) {
                        TagValue tagValue = (TagValue)mktDataOptions.get(i);
                        mktDataOptionsStr.append( tagValue.m_tag);
                        mktDataOptionsStr.append( "=");
                        mktDataOptionsStr.append( tagValue.m_value);
                        mktDataOptionsStr.append( ";");
                    }
                }
                send( mktDataOptionsStr.toString());
            }
            
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_REQMKT, "" + e);
            close();
        }
    }

    public synchronized void cancelHistoricalData( int tickerId ) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < 24) {
          error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                "  It does not support historical data query cancellation.");
          return;
        }

        final int VERSION = 1;

        // send cancel mkt data msg
        try {
            send( CANCEL_HISTORICAL_DATA);
            send( VERSION);
            send( tickerId);
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_CANHISTDATA, "" + e);
            close();
        }
    }

    public void cancelRealTimeBars(int tickerId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REAL_TIME_BARS) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                  "  It does not support realtime bar data query cancellation.");
            return;
        }

        final int VERSION = 1;

        // send cancel mkt data msg
        try {
            send( CANCEL_REAL_TIME_BARS);
            send( VERSION);
            send( tickerId);
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_CANRTBARS, "" + e);
            close();
        }
    }

    /** Note that formatData parameter affects intra-day bars only; 1-day bars always return with date in YYYYMMDD format. */
    public synchronized void reqHistoricalData( int tickerId, Contract contract,
                                                String endDateTime, String durationStr,
                                                String barSizeSetting, String whatToShow,
                                                int useRTH, int formatDate, List<TagValue> chartOptions) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 6;

        try {
          if (m_serverVersion < 16) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                  "  It does not support historical data backfill.");
            return;
          }

          if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
              if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {
                  error(tickerId, EClientErrors.UPDATE_TWS,
                      "  It does not support conId and tradingClass parameters in reqHistroricalData.");
                  return;
              }
          }

          send(REQ_HISTORICAL_DATA);
          send(VERSION);
          send(tickerId);

          // send contract fields
          if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
              send(contract.m_conId);
          }
          send(contract.m_symbol);
          send(contract.m_secType);
          send(contract.m_expiry);
          send(contract.m_strike);
          send(contract.m_right);
          send(contract.m_multiplier);
          send(contract.m_exchange);
          send(contract.m_primaryExch);
          send(contract.m_currency);
          send(contract.m_localSymbol);
          if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
              send(contract.m_tradingClass);
          }
          if (m_serverVersion >= 31) {
        	  send(contract.m_includeExpired ? 1 : 0);
          }
          if (m_serverVersion >= 20) {
              send(endDateTime);
              send(barSizeSetting);
          }
          send(durationStr);
          send(useRTH);
          send(whatToShow);
          if (m_serverVersion > 16) {
              send(formatDate);
          }
          if (BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
              if (contract.m_comboLegs == null) {
                  send(0);
              }
              else {
                  send(contract.m_comboLegs.size());

                  ComboLeg comboLeg;
                  for (int i = 0; i < contract.m_comboLegs.size(); i++) {
                      comboLeg = contract.m_comboLegs.get(i);
                      send(comboLeg.m_conId);
                      send(comboLeg.m_ratio);
                      send(comboLeg.m_action);
                      send(comboLeg.m_exchange);
                  }
              }
          }
          
          // send chartOptions parameter
          if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
              StringBuilder chartOptionsStr = new StringBuilder();
              int chartOptionsCount = chartOptions == null ? 0 : chartOptions.size();
              if( chartOptionsCount > 0) {
                  for( int i = 0; i < chartOptionsCount; ++i) {
                      TagValue tagValue = (TagValue)chartOptions.get(i);
                      chartOptionsStr.append( tagValue.m_tag);
                      chartOptionsStr.append( "=");
                      chartOptionsStr.append( tagValue.m_value);
                      chartOptionsStr.append( ";");
                  }
              }
              send( chartOptionsStr.toString());
          }
          
        }
        catch (Exception e) {
          error(tickerId, EClientErrors.FAIL_SEND_REQHISTDATA, "" + e);
          close();
        }
    }

    public synchronized void reqRealTimeBars(int tickerId, Contract contract, int barSize, String whatToShow, boolean useRTH, Vector<TagValue> realTimeBarsOptions) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REAL_TIME_BARS) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                  "  It does not support real time bars.");
            return;
        }
        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {
                  error(tickerId, EClientErrors.UPDATE_TWS,
                      "  It does not support conId and tradingClass parameters in reqRealTimeBars.");
                  return;
            }
        }

        final int VERSION = 3;

        try {
            // send req mkt data msg
            send(REQ_REAL_TIME_BARS);
            send(VERSION);
            send(tickerId);

            // send contract fields
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_conId);
            }
            send(contract.m_symbol);
            send(contract.m_secType);
            send(contract.m_expiry);
            send(contract.m_strike);
            send(contract.m_right);
            send(contract.m_multiplier);
            send(contract.m_exchange);
            send(contract.m_primaryExch);
            send(contract.m_currency);
            send(contract.m_localSymbol);
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }
            send(barSize);  // this parameter is not currently used
            send(whatToShow);
            send(useRTH);

            // send realTimeBarsOptions parameter
            if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
                StringBuilder realTimeBarsOptionsStr = new StringBuilder();
                int realTimeBarsOptionsCount = realTimeBarsOptions == null ? 0 : realTimeBarsOptions.size();
                if( realTimeBarsOptionsCount > 0) {
                    for( int i = 0; i < realTimeBarsOptionsCount; ++i) {
                        TagValue tagValue = (TagValue)realTimeBarsOptions.get(i);
                        realTimeBarsOptionsStr.append( tagValue.m_tag);
                        realTimeBarsOptionsStr.append( "=");
                        realTimeBarsOptionsStr.append( tagValue.m_value);
                        realTimeBarsOptionsStr.append( ";");
                    }
                }
                send( realTimeBarsOptionsStr.toString());
            }
            
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_REQRTBARS, "" + e);
            close();
        }
    }

    public synchronized void reqContractDetails(int reqId, Contract contract) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >=4
        if( m_serverVersion < 4) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(),
                            EClientErrors.UPDATE_TWS.msg());
            return;
        }

        if( m_serverVersion < MIN_SERVER_VER_SEC_ID_TYPE) {
        	if (!IsEmpty(contract.m_secIdType) || !IsEmpty(contract.m_secId)) {
        		error(reqId, EClientErrors.UPDATE_TWS,
        			"  It does not support secIdType and secId parameters.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass)) {
                  error(reqId, EClientErrors.UPDATE_TWS,
                      "  It does not support tradingClass parameter in reqContractDetails.");
                  return;
            }
        }

        final int VERSION = 7;

        try {
            // send req mkt data msg
            send( REQ_CONTRACT_DATA);
            send( VERSION);

            if (m_serverVersion >= MIN_SERVER_VER_CONTRACT_DATA_CHAIN) {
            	send( reqId);
            }

            // send contract fields
            if (m_serverVersion >= MIN_SERVER_VER_CONTRACT_CONID) {
            	send(contract.m_conId);
            }
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_expiry);
            send( contract.m_strike);
            send( contract.m_right);
            if (m_serverVersion >= 15) {
                send(contract.m_multiplier);
            }
            send( contract.m_exchange);
            send( contract.m_currency);
            send( contract.m_localSymbol);
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }
            if (m_serverVersion >= 31) {
                send(contract.m_includeExpired);
            }
            if (m_serverVersion >= MIN_SERVER_VER_SEC_ID_TYPE) {
            	send( contract.m_secIdType);
            	send( contract.m_secId);
            }

        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQCONTRACT, "" + e);
            close();
        }
    }

    public synchronized void reqMktDepth( int tickerId, Contract contract, int numRows, Vector<TagValue> mktDepthOptions) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >=6
        if( m_serverVersion < 6) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(),
                    EClientErrors.UPDATE_TWS.msg());
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {
                  error(tickerId, EClientErrors.UPDATE_TWS,
                      "  It does not support conId and tradingClass parameters in reqMktDepth.");
                  return;
            }
        }

        final int VERSION = 5;

        try {
            // send req mkt data msg
            send( REQ_MKT_DEPTH);
            send( VERSION);
            send( tickerId);

            // send contract fields
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_conId);
            }
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_expiry);
            send( contract.m_strike);
            send( contract.m_right);
            if (m_serverVersion >= 15) {
              send(contract.m_multiplier);
            }
            send( contract.m_exchange);
            send( contract.m_currency);
            send( contract.m_localSymbol);
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }
            if (m_serverVersion >= 19) {
                send( numRows);
            }
            
            // send mktDepthOptions parameter
            if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
                StringBuilder mktDepthOptionsStr = new StringBuilder();
                int mktDepthOptionsCount = mktDepthOptions == null ? 0 : mktDepthOptions.size();
                if( mktDepthOptionsCount > 0) {
                    for( int i = 0; i < mktDepthOptionsCount; ++i) {
                        TagValue tagValue = (TagValue)mktDepthOptions.get(i);
                        mktDepthOptionsStr.append( tagValue.m_tag);
                        mktDepthOptionsStr.append( "=");
                        mktDepthOptionsStr.append( tagValue.m_value);
                        mktDepthOptionsStr.append( ";");
                    }
                }
                send( mktDepthOptionsStr.toString());
            }
            
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_REQMKTDEPTH, "" + e);
            close();
        }
    }

    public synchronized void cancelMktData( int tickerId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send cancel mkt data msg
        try {
            send( CANCEL_MKT_DATA);
            send( VERSION);
            send( tickerId);
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_CANMKT, "" + e);
            close();
        }
    }

    public synchronized void cancelMktDepth( int tickerId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >=6
        if( m_serverVersion < 6) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(),
                    EClientErrors.UPDATE_TWS.msg());
            return;
        }

        final int VERSION = 1;

        // send cancel mkt data msg
        try {
            send( CANCEL_MKT_DEPTH);
            send( VERSION);
            send( tickerId);
        }
        catch( Exception e) {
            error( tickerId, EClientErrors.FAIL_SEND_CANMKTDEPTH, "" + e);
            close();
        }
    }

    public synchronized void exerciseOptions( int tickerId, Contract contract,
                                              int exerciseAction, int exerciseQuantity,
                                              String account, int override) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 2;

        try {
          if (m_serverVersion < 21) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                  "  It does not support options exercise from the API.");
            return;
          }

          if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
              if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {
                    error(tickerId, EClientErrors.UPDATE_TWS,
                        "  It does not support conId and tradingClass parameters in exerciseOptions.");
                    return;
              }
          }

          send(EXERCISE_OPTIONS);
          send(VERSION);
          send(tickerId);

          // send contract fields
          if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
              send(contract.m_conId);
          }
          send(contract.m_symbol);
          send(contract.m_secType);
          send(contract.m_expiry);
          send(contract.m_strike);
          send(contract.m_right);
          send(contract.m_multiplier);
          send(contract.m_exchange);
          send(contract.m_currency);
          send(contract.m_localSymbol);
          if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
              send(contract.m_tradingClass);
          }
          send(exerciseAction);
          send(exerciseQuantity);
          send(account);
          send(override);
      }
      catch (Exception e) {
        error(tickerId, EClientErrors.FAIL_SEND_REQMKT, "" + e);
        close();
      }
    }

    public synchronized void placeOrder( int id, Contract contract, Order order) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_SCALE_ORDERS) {
        	if (order.m_scaleInitLevelSize != Integer.MAX_VALUE ||
        		order.m_scalePriceIncrement != Double.MAX_VALUE) {
        		error(id, EClientErrors.UPDATE_TWS,
            		"  It does not support Scale orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SSHORT_COMBO_LEGS) {
        	if (!contract.m_comboLegs.isEmpty()) {
                ComboLeg comboLeg;
                for (int i = 0; i < contract.m_comboLegs.size(); ++i) {
                    comboLeg = contract.m_comboLegs.get(i);
                    if (comboLeg.m_shortSaleSlot != 0 ||
                    	!IsEmpty(comboLeg.m_designatedLocation)) {
                		error(id, EClientErrors.UPDATE_TWS,
                			"  It does not support SSHORT flag for combo legs.");
                		return;
                    }
                }
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_WHAT_IF_ORDERS) {
        	if (order.m_whatIf) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support what-if orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_UNDER_COMP) {
        	if (contract.m_underComp != null) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support delta-neutral orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SCALE_ORDERS2) {
        	if (order.m_scaleSubsLevelSize != Integer.MAX_VALUE) {
        		error(id, EClientErrors.UPDATE_TWS,
            		"  It does not support Subsequent Level Size for Scale orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_ALGO_ORDERS) {
        	if (!IsEmpty(order.m_algoStrategy)) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support algo orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_NOT_HELD) {
        	if (order.m_notHeld) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support notHeld parameter.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SEC_ID_TYPE) {
        	if (!IsEmpty(contract.m_secIdType) || !IsEmpty(contract.m_secId)) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support secIdType and secId parameters.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_PLACE_ORDER_CONID) {
        	if (contract.m_conId > 0) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support conId parameter.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SSHORTX) {
        	if (order.m_exemptCode != -1) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support exemptCode parameter.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SSHORTX) {
        	if (!contract.m_comboLegs.isEmpty()) {
                ComboLeg comboLeg;
                for (int i = 0; i < contract.m_comboLegs.size(); ++i) {
                    comboLeg = contract.m_comboLegs.get(i);
                    if (comboLeg.m_exemptCode != -1) {
                		error(id, EClientErrors.UPDATE_TWS,
                			"  It does not support exemptCode parameter.");
                		return;
                    }
                }
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_HEDGE_ORDERS) {
        	if (!IsEmpty(order.m_hedgeType)) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support hedge orders.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_OPT_OUT_SMART_ROUTING) {
        	if (order.m_optOutSmartRouting) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support optOutSmartRouting parameter.");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_DELTA_NEUTRAL_CONID) {
        	if (order.m_deltaNeutralConId > 0
        			|| !IsEmpty(order.m_deltaNeutralSettlingFirm)
        			|| !IsEmpty(order.m_deltaNeutralClearingAccount)
        			|| !IsEmpty(order.m_deltaNeutralClearingIntent)
        			) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support deltaNeutral parameters: ConId, SettlingFirm, ClearingAccount, ClearingIntent");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_DELTA_NEUTRAL_OPEN_CLOSE) {
        	if (!IsEmpty(order.m_deltaNeutralOpenClose)
        			|| order.m_deltaNeutralShortSale
        			|| order.m_deltaNeutralShortSaleSlot > 0
        			|| !IsEmpty(order.m_deltaNeutralDesignatedLocation)
        			) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support deltaNeutral parameters: OpenClose, ShortSale, ShortSaleSlot, DesignatedLocation");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_SCALE_ORDERS3) {
        	if (order.m_scalePriceIncrement > 0 && order.m_scalePriceIncrement != Double.MAX_VALUE) {
        		if (order.m_scalePriceAdjustValue != Double.MAX_VALUE ||
        			order.m_scalePriceAdjustInterval != Integer.MAX_VALUE ||
        			order.m_scaleProfitOffset != Double.MAX_VALUE ||
        			order.m_scaleAutoReset ||
        			order.m_scaleInitPosition != Integer.MAX_VALUE ||
        			order.m_scaleInitFillQty != Integer.MAX_VALUE ||
        			order.m_scaleRandomPercent) {
        			error(id, EClientErrors.UPDATE_TWS,
        				"  It does not support Scale order parameters: PriceAdjustValue, PriceAdjustInterval, " +
        				"ProfitOffset, AutoReset, InitPosition, InitFillQty and RandomPercent");
        			return;
        		}
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_ORDER_COMBO_LEGS_PRICE && BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
        	if (!order.m_orderComboLegs.isEmpty()) {
        		OrderComboLeg orderComboLeg;
        		for (int i = 0; i < order.m_orderComboLegs.size(); ++i) {
        			orderComboLeg = order.m_orderComboLegs.get(i);
        			if (orderComboLeg.m_price != Double.MAX_VALUE) {
        			error(id, EClientErrors.UPDATE_TWS,
        				"  It does not support per-leg prices for order combo legs.");
        			return;
        			}
        		}
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_TRAILING_PERCENT) {
        	if (order.m_trailingPercent != Double.MAX_VALUE) {
        		error(id, EClientErrors.UPDATE_TWS,
        			"  It does not support trailing percent parameter");
        		return;
        	}
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass)) {
                  error(id, EClientErrors.UPDATE_TWS,
                      "  It does not support tradingClass parameters in placeOrder.");
                  return;
            }
        }

        if (m_serverVersion < MIN_SERVER_VER_SCALE_TABLE) {
            if (!IsEmpty(order.m_scaleTable) || !IsEmpty(order.m_activeStartTime) || !IsEmpty(order.m_activeStopTime)) {
                  error(id, EClientErrors.UPDATE_TWS,
                      "  It does not support scaleTable, activeStartTime and activeStopTime parameters.");
                  return;
            }
        }

        int VERSION = (m_serverVersion < MIN_SERVER_VER_NOT_HELD) ? 27 : 42;

        // send place order msg
        try {
            send( PLACE_ORDER);
            send( VERSION);
            send( id);

            // send contract fields
            if( m_serverVersion >= MIN_SERVER_VER_PLACE_ORDER_CONID) {
                send(contract.m_conId);
            }
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_expiry);
            send( contract.m_strike);
            send( contract.m_right);
            if (m_serverVersion >= 15) {
                send(contract.m_multiplier);
            }
            send( contract.m_exchange);
            if( m_serverVersion >= 14) {
              send(contract.m_primaryExch);
            }
            send( contract.m_currency);
            if( m_serverVersion >= 2) {
                send (contract.m_localSymbol);
            }
            if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }
            if( m_serverVersion >= MIN_SERVER_VER_SEC_ID_TYPE){
            	send( contract.m_secIdType);
            	send( contract.m_secId);
            }

            // send main order fields
            send( order.m_action);
            send( order.m_totalQuantity);
            send( order.m_orderType);
            if (m_serverVersion < MIN_SERVER_VER_ORDER_COMBO_LEGS_PRICE) {
                send( order.m_lmtPrice == Double.MAX_VALUE ? 0 : order.m_lmtPrice);
            }
            else {
                sendMax( order.m_lmtPrice);
            }
            if (m_serverVersion < MIN_SERVER_VER_TRAILING_PERCENT) {
                send( order.m_auxPrice == Double.MAX_VALUE ? 0 : order.m_auxPrice);
            }
            else {
                sendMax( order.m_auxPrice);
            }

            // send extended order fields
            send( order.m_tif);
            send( order.m_ocaGroup);
            send( order.m_account);
            send( order.m_openClose);
            send( order.m_origin);
            send( order.m_orderRef);
            send( order.m_transmit);
            if( m_serverVersion >= 4 ) {
                send (order.m_parentId);
            }

            if( m_serverVersion >= 5 ) {
                send (order.m_blockOrder);
                send (order.m_sweepToFill);
                send (order.m_displaySize);
                send (order.m_triggerMethod);
                if (m_serverVersion < 38) {
                	// will never happen
                	send(/* order.m_ignoreRth */ false);
                }
                else {
                	send (order.m_outsideRth);
                }
            }

            if(m_serverVersion >= 7 ) {
                send(order.m_hidden);
            }

            // Send combo legs for BAG requests
            if(m_serverVersion >= 8 && BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
                if ( contract.m_comboLegs == null ) {
                    send( 0);
                }
                else {
                    send( contract.m_comboLegs.size());

                    ComboLeg comboLeg;
                    for (int i=0; i < contract.m_comboLegs.size(); i ++) {
                        comboLeg = contract.m_comboLegs.get(i);
                        send( comboLeg.m_conId);
                        send( comboLeg.m_ratio);
                        send( comboLeg.m_action);
                        send( comboLeg.m_exchange);
                        send( comboLeg.m_openClose);

                        if (m_serverVersion >= MIN_SERVER_VER_SSHORT_COMBO_LEGS) {
                        	send( comboLeg.m_shortSaleSlot);
                        	send( comboLeg.m_designatedLocation);
                        }
                        if (m_serverVersion >= MIN_SERVER_VER_SSHORTX_OLD) {
                            send( comboLeg.m_exemptCode);
                        }
                    }
                }
            }

            // Send order combo legs for BAG requests
            if(m_serverVersion >= MIN_SERVER_VER_ORDER_COMBO_LEGS_PRICE && BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
                if ( order.m_orderComboLegs == null ) {
                    send( 0);
                }
                else {
                    send( order.m_orderComboLegs.size());

                    for (int i = 0; i < order.m_orderComboLegs.size(); i++) {
                        OrderComboLeg orderComboLeg = order.m_orderComboLegs.get(i);
                        sendMax( orderComboLeg.m_price);
                    }
                }
            }

            if(m_serverVersion >= MIN_SERVER_VER_SMART_COMBO_ROUTING_PARAMS && BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {
                java.util.Vector smartComboRoutingParams = order.m_smartComboRoutingParams;
                int smartComboRoutingParamsCount = smartComboRoutingParams == null ? 0 : smartComboRoutingParams.size();
                send( smartComboRoutingParamsCount);
                if( smartComboRoutingParamsCount > 0) {
                    for( int i = 0; i < smartComboRoutingParamsCount; ++i) {
                        TagValue tagValue = (TagValue)smartComboRoutingParams.get(i);
                        send( tagValue.m_tag);
                        send( tagValue.m_value);
                    }
                }
            }

            if ( m_serverVersion >= 9 ) {
            	// send deprecated sharesAllocation field
                send( "");
            }

            if ( m_serverVersion >= 10 ) {
                send( order.m_discretionaryAmt);
            }

            if ( m_serverVersion >= 11 ) {
                send( order.m_goodAfterTime);
            }

            if ( m_serverVersion >= 12 ) {
                send( order.m_goodTillDate);
            }

            if ( m_serverVersion >= 13 ) {
               send( order.m_faGroup);
               send( order.m_faMethod);
               send( order.m_faPercentage);
               send( order.m_faProfile);
           }
           if (m_serverVersion >= 18) { // institutional short sale slot fields.
               send( order.m_shortSaleSlot);      // 0 only for retail, 1 or 2 only for institution.
               send( order.m_designatedLocation); // only populate when order.m_shortSaleSlot = 2.
           }
           if (m_serverVersion >= MIN_SERVER_VER_SSHORTX_OLD) {
               send( order.m_exemptCode);
           }
           if (m_serverVersion >= 19) {
               send( order.m_ocaType);
               if (m_serverVersion < 38) {
            	   // will never happen
            	   send( /* order.m_rthOnly */ false);
               }
               send( order.m_rule80A);
               send( order.m_settlingFirm);
               send( order.m_allOrNone);
               sendMax( order.m_minQty);
               sendMax( order.m_percentOffset);
               send( order.m_eTradeOnly);
               send( order.m_firmQuoteOnly);
               sendMax( order.m_nbboPriceCap);
               sendMax( order.m_auctionStrategy);
               sendMax( order.m_startingPrice);
               sendMax( order.m_stockRefPrice);
               sendMax( order.m_delta);
        	   // Volatility orders had specific watermark price attribs in server version 26
        	   double lower = (m_serverVersion == 26 && order.m_orderType.equals("VOL"))
        	   		? Double.MAX_VALUE
        	   		: order.m_stockRangeLower;
        	   double upper = (m_serverVersion == 26 && order.m_orderType.equals("VOL"))
   	   				? Double.MAX_VALUE
   	   				: order.m_stockRangeUpper;
               sendMax( lower);
               sendMax( upper);
           }

           if (m_serverVersion >= 22) {
               send( order.m_overridePercentageConstraints);
           }

           if (m_serverVersion >= 26) { // Volatility orders
               sendMax( order.m_volatility);
               sendMax( order.m_volatilityType);
               if (m_serverVersion < 28) {
            	   send( order.m_deltaNeutralOrderType.equalsIgnoreCase("MKT"));
               } else {
            	   send( order.m_deltaNeutralOrderType);
            	   sendMax( order.m_deltaNeutralAuxPrice);

                   if (m_serverVersion >= MIN_SERVER_VER_DELTA_NEUTRAL_CONID && !IsEmpty(order.m_deltaNeutralOrderType)){
                       send( order.m_deltaNeutralConId);
                       send( order.m_deltaNeutralSettlingFirm);
                       send( order.m_deltaNeutralClearingAccount);
                       send( order.m_deltaNeutralClearingIntent);
                   }

                   if (m_serverVersion >= MIN_SERVER_VER_DELTA_NEUTRAL_OPEN_CLOSE && !IsEmpty(order.m_deltaNeutralOrderType)){
                       send( order.m_deltaNeutralOpenClose);
                       send( order.m_deltaNeutralShortSale);
                       send( order.m_deltaNeutralShortSaleSlot);
                       send( order.m_deltaNeutralDesignatedLocation);
                   }
               }
               send( order.m_continuousUpdate);
               if (m_serverVersion == 26) {
            	   // Volatility orders had specific watermark price attribs in server version 26
            	   double lower = order.m_orderType.equals("VOL") ? order.m_stockRangeLower : Double.MAX_VALUE;
            	   double upper = order.m_orderType.equals("VOL") ? order.m_stockRangeUpper : Double.MAX_VALUE;
                   sendMax( lower);
                   sendMax( upper);
               }
               sendMax( order.m_referencePriceType);
           }

           if (m_serverVersion >= 30) { // TRAIL_STOP_LIMIT stop price
               sendMax( order.m_trailStopPrice);
           }

           if( m_serverVersion >= MIN_SERVER_VER_TRAILING_PERCENT){
               sendMax( order.m_trailingPercent);
           }

           if (m_serverVersion >= MIN_SERVER_VER_SCALE_ORDERS) {
        	   if (m_serverVersion >= MIN_SERVER_VER_SCALE_ORDERS2) {
        		   sendMax (order.m_scaleInitLevelSize);
        		   sendMax (order.m_scaleSubsLevelSize);
        	   }
        	   else {
        		   send ("");
        		   sendMax (order.m_scaleInitLevelSize);

        	   }
        	   sendMax (order.m_scalePriceIncrement);
           }

           if (m_serverVersion >= MIN_SERVER_VER_SCALE_ORDERS3 && order.m_scalePriceIncrement > 0.0 && order.m_scalePriceIncrement != Double.MAX_VALUE) {
               sendMax (order.m_scalePriceAdjustValue);
               sendMax (order.m_scalePriceAdjustInterval);
               sendMax (order.m_scaleProfitOffset);
               send (order.m_scaleAutoReset);
               sendMax (order.m_scaleInitPosition);
               sendMax (order.m_scaleInitFillQty);
               send (order.m_scaleRandomPercent);
           }

           if (m_serverVersion >= MIN_SERVER_VER_SCALE_TABLE) {
               send (order.m_scaleTable);
               send (order.m_activeStartTime);
               send (order.m_activeStopTime);
           }

           if (m_serverVersion >= MIN_SERVER_VER_HEDGE_ORDERS) {
        	   send (order.m_hedgeType);
        	   if (!IsEmpty(order.m_hedgeType)) {
        		   send (order.m_hedgeParam);
        	   }
           }

           if (m_serverVersion >= MIN_SERVER_VER_OPT_OUT_SMART_ROUTING) {
               send (order.m_optOutSmartRouting);
           }

           if (m_serverVersion >= MIN_SERVER_VER_PTA_ORDERS) {
        	   send (order.m_clearingAccount);
        	   send (order.m_clearingIntent);
           }

           if (m_serverVersion >= MIN_SERVER_VER_NOT_HELD) {
        	   send (order.m_notHeld);
           }

           if (m_serverVersion >= MIN_SERVER_VER_UNDER_COMP) {
        	   if (contract.m_underComp != null) {
        		   UnderComp underComp = contract.m_underComp;
        		   send( true);
        		   send( underComp.m_conId);
        		   send( underComp.m_delta);
        		   send( underComp.m_price);
        	   }
        	   else {
        		   send( false);
        	   }
           }

           if (m_serverVersion >= MIN_SERVER_VER_ALGO_ORDERS) {
        	   send( order.m_algoStrategy);
        	   if( !IsEmpty(order.m_algoStrategy)) {
        		   java.util.Vector algoParams = order.m_algoParams;
        		   int algoParamsCount = algoParams == null ? 0 : algoParams.size();
        		   send( algoParamsCount);
        		   if( algoParamsCount > 0) {
        			   for( int i = 0; i < algoParamsCount; ++i) {
        				   TagValue tagValue = (TagValue)algoParams.get(i);
        				   send( tagValue.m_tag);
        				   send( tagValue.m_value);
        			   }
        		   }
        	   }
           }

           if (m_serverVersion >= MIN_SERVER_VER_WHAT_IF_ORDERS) {
        	   send (order.m_whatIf);
           }
           
           // send orderMiscOptions parameter
           if(m_serverVersion >= MIN_SERVER_VER_LINKING) {
               StringBuilder orderMiscOptionsStr = new StringBuilder();
               java.util.Vector orderMiscOptions = order.m_orderMiscOptions;
               int orderMiscOptionsCount = orderMiscOptions == null ? 0 : orderMiscOptions.size();
               if( orderMiscOptionsCount > 0) {
                   for( int i = 0; i < orderMiscOptionsCount; ++i) {
                       TagValue tagValue = (TagValue)orderMiscOptions.get(i);
                       orderMiscOptionsStr.append( tagValue.m_tag);
                       orderMiscOptionsStr.append( "=");
                       orderMiscOptionsStr.append( tagValue.m_value);
                       orderMiscOptionsStr.append( ";");
                   }
               }
               send( orderMiscOptionsStr.toString());
           }
           
        }
        catch( Exception e) {
            error( id, EClientErrors.FAIL_SEND_ORDER, "" + e);
            close();
        }
    }

    public synchronized void reqAccountUpdates(boolean subscribe, String acctCode) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 2;

        // send cancel order msg
        try {
            send( REQ_ACCOUNT_DATA );
            send( VERSION);
            send( subscribe);

            // Send the account code. This will only be used for FA clients
            if ( m_serverVersion >= 9 ) {
                send( acctCode);
            }
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_ACCT, "" + e);
            close();
        }
    }

    public synchronized void reqExecutions(int reqId, ExecutionFilter filter) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 3;

        // send cancel order msg
        try {
            send( REQ_EXECUTIONS);
            send( VERSION);

            if (m_serverVersion >= MIN_SERVER_VER_EXECUTION_DATA_CHAIN) {
            	send( reqId);
            }

            // Send the execution rpt filter data
            if ( m_serverVersion >= 9 ) {
                send( filter.m_clientId);
                send( filter.m_acctCode);

                // Note that the valid format for m_time is "yyyymmdd-hh:mm:ss"
                send( filter.m_time);
                send( filter.m_symbol);
                send( filter.m_secType);
                send( filter.m_exchange);
                send( filter.m_side);
            }
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_EXEC, "" + e);
            close();
        }
    }

    public synchronized void cancelOrder( int id) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send cancel order msg
        try {
            send( CANCEL_ORDER);
            send( VERSION);
            send( id);
        }
        catch( Exception e) {
            error( id, EClientErrors.FAIL_SEND_CORDER, "" + e);
            close();
        }
    }

    public synchronized void reqOpenOrders() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send cancel order msg
        try {
            send( REQ_OPEN_ORDERS);
            send( VERSION);
        }
        catch( Exception e) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_OORDER, "" + e);
            close();
        }
    }

    public synchronized void reqIds( int numIds) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        try {
            send( REQ_IDS);
            send( VERSION);
            send( numIds);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_CORDER, "" + e);
            close();
        }
    }

    public synchronized void reqNewsBulletins( boolean allMsgs) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        try {
            send( REQ_NEWS_BULLETINS);
            send( VERSION);
            send( allMsgs);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_CORDER, "" + e);
            close();
        }
    }

    public synchronized void cancelNewsBulletins() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send cancel order msg
        try {
            send( CANCEL_NEWS_BULLETINS);
            send( VERSION);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_CORDER, "" + e);
            close();
        }
    }

    public synchronized void setServerLogLevel(int logLevel) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

                // send the set server logging level message
                try {
                        send( SET_SERVER_LOGLEVEL);
                        send( VERSION);
                        send( logLevel);
                }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_SERVER_LOG_LEVEL, "" + e);
            close();
        }
    }

    public synchronized void reqAutoOpenOrders(boolean bAutoBind) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send req open orders msg
        try {
            send( REQ_AUTO_OPEN_ORDERS);
            send( VERSION);
            send( bAutoBind);
        }
        catch( Exception e) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_OORDER, "" + e);
            close();
        }
    }

    public synchronized void reqAllOpenOrders() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send req all open orders msg
        try {
            send( REQ_ALL_OPEN_ORDERS);
            send( VERSION);
        }
        catch( Exception e) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_OORDER, "" + e);
            close();
        }
    }

    public synchronized void reqManagedAccts() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        final int VERSION = 1;

        // send req FA managed accounts msg
        try {
            send( REQ_MANAGED_ACCTS);
            send( VERSION);
        }
        catch( Exception e) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_OORDER, "" + e);
            close();
        }
    }

    public synchronized void requestFA( int faDataType ) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >= 13
        if( m_serverVersion < 13) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(),
                    EClientErrors.UPDATE_TWS.msg());
            return;
        }

        final int VERSION = 1;

        try {
            send( REQ_FA );
            send( VERSION);
            send( faDataType);
        }
        catch( Exception e) {
            error( faDataType, EClientErrors.FAIL_SEND_FA_REQUEST, "" + e);
            close();
        }
    }

    public synchronized void replaceFA( int faDataType, String xml ) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >= 13
        if( m_serverVersion < 13) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS.code(),
                    EClientErrors.UPDATE_TWS.msg());
            return;
        }

        final int VERSION = 1;

        try {
            send( REPLACE_FA );
            send( VERSION);
            send( faDataType);
            send( xml);
        }
        catch( Exception e) {
            error( faDataType, EClientErrors.FAIL_SEND_FA_REPLACE, "" + e);
            close();
        }
    }

    public synchronized void reqCurrentTime() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        // This feature is only available for versions of TWS >= 33
        if( m_serverVersion < 33) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                  "  It does not support current time requests.");
            return;
        }

        final int VERSION = 1;

        try {
            send( REQ_CURRENT_TIME );
            send( VERSION);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQCURRTIME, "" + e);
            close();
        }
    }

    public synchronized void reqFundamentalData(int reqId, Contract contract, String reportType) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if( m_serverVersion < MIN_SERVER_VER_FUNDAMENTAL_DATA) {
        	error( reqId, EClientErrors.UPDATE_TWS,
        			"  It does not support fundamental data requests.");
        	return;
        }

        if( m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if( contract.m_conId > 0) {
                  error(reqId, EClientErrors.UPDATE_TWS,
                      "  It does not support conId parameter in reqFundamentalData.");
                  return;
            }
        }

        final int VERSION = 2;

        try {
            // send req fund data msg
            send( REQ_FUNDAMENTAL_DATA);
            send( VERSION);
            send( reqId);

            // send contract fields
            if( m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_conId);
            }
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_exchange);
            send( contract.m_primaryExch);
            send( contract.m_currency);
            send( contract.m_localSymbol);

            send( reportType);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_REQFUNDDATA, "" + e);
            close();
        }
    }

    public synchronized void cancelFundamentalData(int reqId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if( m_serverVersion < MIN_SERVER_VER_FUNDAMENTAL_DATA) {
        	error( reqId, EClientErrors.UPDATE_TWS,
        			"  It does not support fundamental data requests.");
        	return;
        }

        final int VERSION = 1;

        try {
            // send req mkt data msg
            send( CANCEL_FUNDAMENTAL_DATA);
            send( VERSION);
            send( reqId);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_CANFUNDDATA, "" + e);
            close();
        }
    }

    public synchronized void calculateImpliedVolatility(int reqId, Contract contract,
            double optionPrice, double underPrice) {

        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REQ_CALC_IMPLIED_VOLAT) {
            error(reqId, EClientErrors.UPDATE_TWS,
                    "  It does not support calculate implied volatility requests.");
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass)) {
                  error(reqId, EClientErrors.UPDATE_TWS,
                      "  It does not support tradingClass parameter in calculateImpliedVolatility.");
                  return;
            }
        }

        final int VERSION = 2;

        try {
            // send calculate implied volatility msg
            send( REQ_CALC_IMPLIED_VOLAT);
            send( VERSION);
            send( reqId);

            // send contract fields
            send( contract.m_conId);
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_expiry);
            send( contract.m_strike);
            send( contract.m_right);
            send( contract.m_multiplier);
            send( contract.m_exchange);
            send( contract.m_primaryExch);
            send( contract.m_currency);
            send( contract.m_localSymbol);
            if( m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }

            send( optionPrice);
            send( underPrice);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_REQCALCIMPLIEDVOLAT, "" + e);
            close();
        }
    }

    public synchronized void cancelCalculateImpliedVolatility(int reqId) {

        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_CANCEL_CALC_IMPLIED_VOLAT) {
            error(reqId, EClientErrors.UPDATE_TWS,
                    "  It does not support calculate implied volatility cancellation.");
            return;
        }

        final int VERSION = 1;

        try {
            // send cancel calculate implied volatility msg
            send( CANCEL_CALC_IMPLIED_VOLAT);
            send( VERSION);
            send( reqId);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_CANCALCIMPLIEDVOLAT, "" + e);
            close();
        }
    }

    public synchronized void calculateOptionPrice(int reqId, Contract contract,
            double volatility, double underPrice) {

        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REQ_CALC_OPTION_PRICE) {
            error(reqId, EClientErrors.UPDATE_TWS,
                    "  It does not support calculate option price requests.");
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {
            if (!IsEmpty(contract.m_tradingClass)) {
                  error(reqId, EClientErrors.UPDATE_TWS,
                      "  It does not support tradingClass parameter in calculateOptionPrice.");
                  return;
            }
        }

        final int VERSION = 2;

        try {
            // send calculate option price msg
            send( REQ_CALC_OPTION_PRICE);
            send( VERSION);
            send( reqId);

            // send contract fields
            send( contract.m_conId);
            send( contract.m_symbol);
            send( contract.m_secType);
            send( contract.m_expiry);
            send( contract.m_strike);
            send( contract.m_right);
            send( contract.m_multiplier);
            send( contract.m_exchange);
            send( contract.m_primaryExch);
            send( contract.m_currency);
            send( contract.m_localSymbol);
            if( m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {
                send(contract.m_tradingClass);
            }

            send( volatility);
            send( underPrice);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_REQCALCOPTIONPRICE, "" + e);
            close();
        }
    }

    public synchronized void cancelCalculateOptionPrice(int reqId) {

        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_CANCEL_CALC_OPTION_PRICE) {
            error(reqId, EClientErrors.UPDATE_TWS,
                    "  It does not support calculate option price cancellation.");
            return;
        }

        final int VERSION = 1;

        try {
            // send cancel calculate option price msg
            send( CANCEL_CALC_OPTION_PRICE);
            send( VERSION);
            send( reqId);
        }
        catch( Exception e) {
            error( reqId, EClientErrors.FAIL_SEND_CANCALCOPTIONPRICE, "" + e);
            close();
        }
    }

    public synchronized void reqGlobalCancel() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REQ_GLOBAL_CANCEL) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                    "  It does not support globalCancel requests.");
            return;
        }

        final int VERSION = 1;

        // send request global cancel msg
        try {
            send( REQ_GLOBAL_CANCEL);
            send( VERSION);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQGLOBALCANCEL, "" + e);
            close();
        }
    }

    public synchronized void reqMarketDataType(int marketDataType) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_REQ_MARKET_DATA_TYPE) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
                    "  It does not support marketDataType requests.");
            return;
        }

        final int VERSION = 1;

        // send the reqMarketDataType message
        try {
            send( REQ_MARKET_DATA_TYPE);
            send( VERSION);
            send( marketDataType);
        }
        catch( Exception e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQMARKETDATATYPE, "" + e);
            close();
        }
    }

    public synchronized void reqPositions() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_ACCT_SUMMARY) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support position requests.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( REQ_POSITIONS);
        b.send( VERSION);


        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQPOSITIONS, "" + e);
        }
    }

    public synchronized void cancelPositions() {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_ACCT_SUMMARY) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support position cancellation.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( CANCEL_POSITIONS);
        b.send( VERSION);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_CANPOSITIONS, "" + e);
        }
    }

    public synchronized void reqAccountSummary( int reqId, String group, String tags) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_ACCT_SUMMARY) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support account summary requests.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( REQ_ACCOUNT_SUMMARY);
        b.send( VERSION);
        b.send( reqId);
        b.send( group);
        b.send( tags);

        try {
           m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_REQACCOUNTDATA, "" + e);
        }
    }

	public synchronized void cancelAccountSummary( int reqId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_ACCT_SUMMARY) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support account summary cancellation.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( CANCEL_ACCOUNT_SUMMARY);
        b.send( VERSION);
        b.send( reqId);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_CANACCOUNTDATA, "" + e);
        }
    }
	
	public synchronized void verifyRequest( String apiName, String apiVersion) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support verification request.");
            return;
        }

        if (!m_extraAuth) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_VERIFYMESSAGE,
            "  Intent to authenticate needs to be expressed during initial connect request.");
            return;
        	
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( VERIFY_REQUEST);
        b.send( VERSION);
        b.send( apiName);
        b.send( apiVersion);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_VERIFYREQUEST, "" + e);
        }
    }

	public synchronized void verifyMessage( String apiData) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support verification message sending.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( VERIFY_MESSAGE);
        b.send( VERSION);
        b.send( apiData);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_VERIFYMESSAGE, "" + e);
        }
    }

	public synchronized void queryDisplayGroups( int reqId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support queryDisplayGroups request.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( QUERY_DISPLAY_GROUPS);
        b.send( VERSION);
        b.send( reqId);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_QUERYDISPLAYGROUPS, "" + e);
        }
    }
	
	public synchronized void subscribeToGroupEvents( int reqId, int groupId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support subscribeToGroupEvents request.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( SUBSCRIBE_TO_GROUP_EVENTS);
        b.send( VERSION);
        b.send( reqId);
        b.send( groupId);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_SUBSCRIBETOGROUPEVENTS, "" + e);
        }
    }	

	public synchronized void updateDisplayGroup( int reqId, String contractInfo) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support updateDisplayGroup request.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( UPDATE_DISPLAY_GROUP);
        b.send( VERSION);
        b.send( reqId);
        b.send( contractInfo);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_UPDATEDISPLAYGROUP, "" + e);
        }
    }	

	public synchronized void unsubscribeFromGroupEvents( int reqId) {
        // not connected?
        if( !m_connected) {
            notConnected();
            return;
        }

        if (m_serverVersion < MIN_SERVER_VER_LINKING) {
            error(EClientErrors.NO_VALID_ID, EClientErrors.UPDATE_TWS,
            "  It does not support unsubscribeFromGroupEvents request.");
            return;
        }

        final int VERSION = 1;

        Builder b = new Builder();
        b.send( UNSUBSCRIBE_FROM_GROUP_EVENTS);
        b.send( VERSION);
        b.send( reqId);

        try {
            m_dos.write( b.getBytes() );
        }
        catch (IOException e) {
            error( EClientErrors.NO_VALID_ID, EClientErrors.FAIL_SEND_UNSUBSCRIBEFROMGROUPEVENTS, "" + e);
        }
    }	
	
    /** @deprecated, never called. */
    protected synchronized void error( String err) {
        m_anyWrapper.error( err);
    }

    protected synchronized void error( int id, int errorCode, String errorMsg) {
        m_anyWrapper.error( id, errorCode, errorMsg);
    }

    protected void close() {
        eDisconnect();
        wrapper().connectionClosed();
    }

    private static boolean is( String str) {
        // return true if the string is not empty
        return str != null && str.length() > 0;
    }

    private static boolean isNull( String str) {
        // return true if the string is null or empty
        return !is( str);
    }

    protected void error(int id, EClientErrors.CodeMsgPair pair, String tail) {
        error(id, pair.code(), pair.msg() + tail);
    }

    protected void send( String str) throws IOException {
        // write string to data buffer; writer thread will
        // write it to socket
        if( !IsEmpty(str)) {
            m_dos.write( str.getBytes() );
        }
        sendEOL();
    }

    private void sendEOL() throws IOException {
        m_dos.write( EOL);
    }

    protected void send( int val) throws IOException {
        send( String.valueOf( val) );
    }

    protected void send( char val) throws IOException {
        m_dos.write( val);
        sendEOL();
    }

    protected void send( double val) throws IOException {
        send( String.valueOf( val) );
    }

    protected void send( long val) throws IOException {
        send( String.valueOf( val) );
    }

    private void sendMax( double val) throws IOException {
        if (val == Double.MAX_VALUE) {
            sendEOL();
        }
        else {
            send(String.valueOf(val));
        }
    }

    private void sendMax( int val) throws IOException {
        if (val == Integer.MAX_VALUE) {
            sendEOL();
        }
        else {
            send(String.valueOf(val));
        }
    }

    protected void send( boolean val) throws IOException {
        send( val ? 1 : 0);
    }

    private static boolean IsEmpty(String str) {
    	return Util.StringIsEmpty(str);
    }

    protected void notConnected() {
        error(EClientErrors.NO_VALID_ID, EClientErrors.NOT_CONNECTED, "");
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/EReader.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.io.DataInputStream;
import java.io.IOException;
import java.util.Vector;

public class EReader extends Thread {

    // incoming msg id's
    static final int TICK_PRICE		= 1;
    static final int TICK_SIZE		= 2;
    static final int ORDER_STATUS	= 3;
    static final int ERR_MSG		= 4;
    static final int OPEN_ORDER         = 5;
    static final int ACCT_VALUE         = 6;
    static final int PORTFOLIO_VALUE    = 7;
    static final int ACCT_UPDATE_TIME   = 8;
    static final int NEXT_VALID_ID      = 9;
    static final int CONTRACT_DATA      = 10;
    static final int EXECUTION_DATA     = 11;
    static final int MARKET_DEPTH     	= 12;
    static final int MARKET_DEPTH_L2    = 13;
    static final int NEWS_BULLETINS    	= 14;
    static final int MANAGED_ACCTS    	= 15;
    static final int RECEIVE_FA    	    = 16;
    static final int HISTORICAL_DATA    = 17;
    static final int BOND_CONTRACT_DATA = 18;
    static final int SCANNER_PARAMETERS = 19;
    static final int SCANNER_DATA       = 20;
    static final int TICK_OPTION_COMPUTATION = 21;
    static final int TICK_GENERIC = 45;
    static final int TICK_STRING = 46;
    static final int TICK_EFP = 47;
    static final int CURRENT_TIME = 49;
    static final int REAL_TIME_BARS = 50;
    static final int FUNDAMENTAL_DATA = 51;
    static final int CONTRACT_DATA_END = 52;
    static final int OPEN_ORDER_END = 53;
    static final int ACCT_DOWNLOAD_END = 54;
    static final int EXECUTION_DATA_END = 55;
    static final int DELTA_NEUTRAL_VALIDATION = 56;
    static final int TICK_SNAPSHOT_END = 57;
    static final int MARKET_DATA_TYPE = 58;
    static final int COMMISSION_REPORT = 59;
    static final int POSITION = 61;
    static final int POSITION_END = 62;
    static final int ACCOUNT_SUMMARY = 63;
    static final int ACCOUNT_SUMMARY_END = 64;
    static final int VERIFY_MESSAGE_API = 65;
    static final int VERIFY_COMPLETED = 66;
    static final int DISPLAY_GROUP_LIST = 67;
    static final int DISPLAY_GROUP_UPDATED = 68;

    private EClientSocket 	m_parent;
    private DataInputStream m_dis;

    protected EClientSocket parent()    { return m_parent; }
    private EWrapper eWrapper()         { return (EWrapper)parent().wrapper(); }

    public EReader( EClientSocket parent, DataInputStream dis) {
        this("EReader", parent, dis);
    }

    protected EReader( String name, EClientSocket parent, DataInputStream dis) {
        setName( name);
        m_parent = parent;
        m_dis = dis;
    }

    public void run() {
        try {
            // loop until thread is terminated
            while( !isInterrupted() && processMsg(readInt()));
        }
        catch ( Exception ex ) {
        	if (parent().isConnected()) {
        		eWrapper().error( ex);
        	}
        }
        if (parent().isConnected()) {
        	m_parent.close();
        }
        try {
            m_dis.close();
            m_dis = null;
            }
            catch (IOException e) {
        }
    }

    /** Overridden in subclass. */
    protected boolean processMsg(int msgId) throws IOException{
        if( msgId == -1) return false;

        switch( msgId) {
            case TICK_PRICE: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                double price = readDouble();
                int size = 0;
                if( version >= 2) {
                    size = readInt();
                }
                int canAutoExecute = 0;
                if (version >= 3) {
                    canAutoExecute = readInt();
                }
                eWrapper().tickPrice( tickerId, tickType, price, canAutoExecute);

                if( version >= 2) {
                    int sizeTickType = -1 ; // not a tick
                    switch (tickType) {
                        case 1: // BID
                            sizeTickType = 0 ; // BID_SIZE
                            break ;
                        case 2: // ASK
                            sizeTickType = 3 ; // ASK_SIZE
                            break ;
                        case 4: // LAST
                            sizeTickType = 5 ; // LAST_SIZE
                            break ;
                    }
                    if (sizeTickType != -1) {
                        eWrapper().tickSize( tickerId, sizeTickType, size);
                    }
                }
                break;
            }
            case TICK_SIZE: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                int size = readInt();

                eWrapper().tickSize( tickerId, tickType, size);
                break;
            }

            case POSITION:{
                int version = readInt();
                String account = readStr();

                Contract contract = new Contract();
                contract.m_conId = readInt();
                contract.m_symbol = readStr();
                contract.m_secType = readStr();
                contract.m_expiry = readStr();
                contract.m_strike = readDouble();
                contract.m_right = readStr();
                contract.m_multiplier = readStr();
                contract.m_exchange = readStr();
                contract.m_currency = readStr();
                contract.m_localSymbol = readStr();
                if (version >= 2) {
                	contract.m_tradingClass = readStr();
                }

                int pos = readInt();
                double avgCost = 0;
                if (version >= 3) {
                	avgCost = readDouble();
                }

                eWrapper().position( account, contract, pos, avgCost);
                break;
            }

            case POSITION_END:{
                int version = readInt();
                eWrapper().positionEnd();
                break;
            }

            case ACCOUNT_SUMMARY:{
                int version = readInt();
                int reqId = readInt();
                String account = readStr();
                String tag = readStr();
                String value = readStr();
                String currency = readStr();
                eWrapper().accountSummary(reqId, account, tag, value, currency);
                break;
            }

            case ACCOUNT_SUMMARY_END:{
                int version = readInt();
                int reqId = readInt();
                eWrapper().accountSummaryEnd(reqId);
                break;
            }

            case TICK_OPTION_COMPUTATION: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                double impliedVol = readDouble();
            	if (impliedVol < 0) { // -1 is the "not yet computed" indicator
            		impliedVol = Double.MAX_VALUE;
            	}
                double delta = readDouble();
            	if (Math.abs(delta) > 1) { // -2 is the "not yet computed" indicator
            		delta = Double.MAX_VALUE;
            	}
            	double optPrice = Double.MAX_VALUE;
            	double pvDividend = Double.MAX_VALUE;
            	double gamma = Double.MAX_VALUE;
            	double vega = Double.MAX_VALUE;
            	double theta = Double.MAX_VALUE;
            	double undPrice = Double.MAX_VALUE;
            	if (version >= 6 || tickType == TickType.MODEL_OPTION) { // introduced in version == 5
            		optPrice = readDouble();
            		if (optPrice < 0) { // -1 is the "not yet computed" indicator
            			optPrice = Double.MAX_VALUE;
            		}
            		pvDividend = readDouble();
            		if (pvDividend < 0) { // -1 is the "not yet computed" indicator
            			pvDividend = Double.MAX_VALUE;
            		}
            	}
            	if (version >= 6) {
            		gamma = readDouble();
            		if (Math.abs(gamma) > 1) { // -2 is the "not yet computed" indicator
            			gamma = Double.MAX_VALUE;
            		}
            		vega = readDouble();
            		if (Math.abs(vega) > 1) { // -2 is the "not yet computed" indicator
            			vega = Double.MAX_VALUE;
            		}
            		theta = readDouble();
            		if (Math.abs(theta) > 1) { // -2 is the "not yet computed" indicator
            			theta = Double.MAX_VALUE;
            		}
            		undPrice = readDouble();
            		if (undPrice < 0) { // -1 is the "not yet computed" indicator
            			undPrice = Double.MAX_VALUE;
            		}
            	}

            	eWrapper().tickOptionComputation( tickerId, tickType, impliedVol, delta, optPrice, pvDividend, gamma, vega, theta, undPrice);
            	break;
            }

            case TICK_GENERIC: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                double value = readDouble();

                eWrapper().tickGeneric( tickerId, tickType, value);
                break;
            }

            case TICK_STRING: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                String value = readStr();

                eWrapper().tickString( tickerId, tickType, value);
                break;
            }

            case TICK_EFP: {
                int version = readInt();
                int tickerId = readInt();
                int tickType = readInt();
                double basisPoints = readDouble();
                String formattedBasisPoints = readStr();
                double impliedFuturesPrice = readDouble();
                int holdDays = readInt();
                String futureExpiry = readStr();
                double dividendImpact = readDouble();
                double dividendsToExpiry = readDouble();
                eWrapper().tickEFP( tickerId, tickType, basisPoints, formattedBasisPoints,
                					impliedFuturesPrice, holdDays, futureExpiry, dividendImpact, dividendsToExpiry);
                break;
            }

            case ORDER_STATUS: {
                int version = readInt();
                int id = readInt();
                String status = readStr();
                int filled = readInt();
                int remaining = readInt();
                double avgFillPrice = readDouble();

                int permId = 0;
                if( version >= 2) {
                    permId = readInt();
                }

                int parentId = 0;
                if( version >= 3) {
                    parentId = readInt();
                }

                double lastFillPrice = 0;
                if( version >= 4) {
                    lastFillPrice = readDouble();
                }

                int clientId = 0;
                if( version >= 5) {
                    clientId = readInt();
                }

                String whyHeld = null;
                if( version >= 6) {
                	whyHeld = readStr();
                }

                eWrapper().orderStatus( id, status, filled, remaining, avgFillPrice,
                                permId, parentId, lastFillPrice, clientId, whyHeld);
                break;
            }

            case ACCT_VALUE: {
                int version = readInt();
                String key = readStr();
                String val  = readStr();
                String cur = readStr();
                String accountName = null ;
                if( version >= 2) {
                    accountName = readStr();
                }
                eWrapper().updateAccountValue(key, val, cur, accountName);
                break;
            }

            case PORTFOLIO_VALUE: {
                int version = readInt();
                Contract contract = new Contract();
                if (version >= 6) {
                	contract.m_conId = readInt();
                }
                contract.m_symbol  = readStr();
                contract.m_secType = readStr();
                contract.m_expiry  = readStr();
                contract.m_strike  = readDouble();
                contract.m_right   = readStr();
                if (version >= 7) {
                	contract.m_multiplier = readStr();
                	contract.m_primaryExch = readStr();
                }
                contract.m_currency = readStr();
                if ( version >= 2 ) {
                    contract.m_localSymbol = readStr();
                }
                if (version >= 8) {
                    contract.m_tradingClass = readStr();
                }

                int position  = readInt();
                double marketPrice = readDouble();
                double marketValue = readDouble();
                double  averageCost = 0.0;
                double  unrealizedPNL = 0.0;
                double  realizedPNL = 0.0;
                if (version >=3 ) {
                    averageCost = readDouble();
                    unrealizedPNL = readDouble();
                    realizedPNL = readDouble();
                }

                String accountName = null ;
                if( version >= 4) {
                    accountName = readStr();
                }

                if(version == 6 && m_parent.serverVersion() == 39) {
                	contract.m_primaryExch = readStr();
                }

                eWrapper().updatePortfolio(contract, position, marketPrice, marketValue,
                                averageCost, unrealizedPNL, realizedPNL, accountName);

                break;
            }

            case ACCT_UPDATE_TIME: {
                int version = readInt();
                String timeStamp = readStr();
                eWrapper().updateAccountTime(timeStamp);
                break;
            }

            case ERR_MSG: {
                int version = readInt();
                if(version < 2) {
                    String msg = readStr();
                    m_parent.error( msg);
                } else {
                    int id = readInt();
                    int errorCode    = readInt();
                    String errorMsg = readStr();
                    m_parent.error(id, errorCode, errorMsg);
                }
                break;
            }

            case OPEN_ORDER: {
                // read version
                int version = readInt();

                // read order id
                Order order = new Order();
                order.m_orderId = readInt();

                // read contract fields
                Contract contract = new Contract();
                if (version >= 17) {
                	contract.m_conId = readInt();
                }
                contract.m_symbol = readStr();
                contract.m_secType = readStr();
                contract.m_expiry = readStr();
                contract.m_strike = readDouble();
                contract.m_right = readStr();
                if ( version >= 32) {
                   contract.m_multiplier = readStr();
                }
                contract.m_exchange = readStr();
                contract.m_currency = readStr();
                if ( version >= 2 ) {
                    contract.m_localSymbol = readStr();
                }
                if (version >= 32) {
                    contract.m_tradingClass = readStr();
                }

                // read order fields
                order.m_action = readStr();
                order.m_totalQuantity = readInt();
                order.m_orderType = readStr();
                if (version < 29) {
                    order.m_lmtPrice = readDouble();
                }
                else {
                    order.m_lmtPrice = readDoubleMax();
                }
                if (version < 30) {
                    order.m_auxPrice = readDouble();
                }
                else {
                    order.m_auxPrice = readDoubleMax();
                }
                order.m_tif = readStr();
                order.m_ocaGroup = readStr();
                order.m_account = readStr();
                order.m_openClose = readStr();
                order.m_origin = readInt();
                order.m_orderRef = readStr();

                if(version >= 3) {
                    order.m_clientId = readInt();
                }

                if( version >= 4 ) {
                    order.m_permId = readInt();
                    if ( version < 18) {
                        // will never happen
                    	/* order.m_ignoreRth = */ readBoolFromInt();
                    }
                    else {
                    	order.m_outsideRth = readBoolFromInt();
                    }
                    order.m_hidden = readInt() == 1;
                    order.m_discretionaryAmt = readDouble();
                }

                if ( version >= 5 ) {
                    order.m_goodAfterTime = readStr();
                }

                if ( version >= 6 ) {
                	// skip deprecated sharesAllocation field
                    readStr();
                }

                if ( version >= 7 ) {
                    order.m_faGroup = readStr();
                    order.m_faMethod = readStr();
                    order.m_faPercentage = readStr();
                    order.m_faProfile = readStr();
                }

                if ( version >= 8 ) {
                    order.m_goodTillDate = readStr();
                }

                if ( version >= 9) {
                    order.m_rule80A = readStr();
                    order.m_percentOffset = readDoubleMax();
                    order.m_settlingFirm = readStr();
                    order.m_shortSaleSlot = readInt();
                    order.m_designatedLocation = readStr();
                    if ( m_parent.serverVersion() == 51){
                        readInt(); // exemptCode
                    }
                    else if ( version >= 23){
                    	order.m_exemptCode = readInt();
                    }
                    order.m_auctionStrategy = readInt();
                    order.m_startingPrice = readDoubleMax();
                    order.m_stockRefPrice = readDoubleMax();
                    order.m_delta = readDoubleMax();
                    order.m_stockRangeLower = readDoubleMax();
                    order.m_stockRangeUpper = readDoubleMax();
                    order.m_displaySize = readInt();
                    if ( version < 18) {
                        // will never happen
                    	/* order.m_rthOnly = */ readBoolFromInt();
                    }
                    order.m_blockOrder = readBoolFromInt();
                    order.m_sweepToFill = readBoolFromInt();
                    order.m_allOrNone = readBoolFromInt();
                    order.m_minQty = readIntMax();
                    order.m_ocaType = readInt();
                    order.m_eTradeOnly = readBoolFromInt();
                    order.m_firmQuoteOnly = readBoolFromInt();
                    order.m_nbboPriceCap = readDoubleMax();
                }

                if ( version >= 10) {
                    order.m_parentId = readInt();
                    order.m_triggerMethod = readInt();
                }

                if (version >= 11) {
                    order.m_volatility = readDoubleMax();
                    order.m_volatilityType = readInt();
                    if (version == 11) {
                    	int receivedInt = readInt();
                    	order.m_deltaNeutralOrderType = ( (receivedInt == 0) ? "NONE" : "MKT" );
                    } else { // version 12 and up
                    	order.m_deltaNeutralOrderType = readStr();
                    	order.m_deltaNeutralAuxPrice = readDoubleMax();

                        if (version >= 27 && !Util.StringIsEmpty(order.m_deltaNeutralOrderType)) {
                            order.m_deltaNeutralConId = readInt();
                            order.m_deltaNeutralSettlingFirm = readStr();
                            order.m_deltaNeutralClearingAccount = readStr();
                            order.m_deltaNeutralClearingIntent = readStr();
                        }

                        if (version >= 31 && !Util.StringIsEmpty(order.m_deltaNeutralOrderType)) {
                            order.m_deltaNeutralOpenClose = readStr();
                            order.m_deltaNeutralShortSale = readBoolFromInt();
                            order.m_deltaNeutralShortSaleSlot = readInt();
                            order.m_deltaNeutralDesignatedLocation = readStr();
                        }
                    }
                    order.m_continuousUpdate = readInt();
                    if (m_parent.serverVersion() == 26) {
                    	order.m_stockRangeLower = readDouble();
                    	order.m_stockRangeUpper = readDouble();
                    }
                    order.m_referencePriceType = readInt();
                }

                if (version >= 13) {
                	order.m_trailStopPrice = readDoubleMax();
                }

                if (version >= 30) {
                	order.m_trailingPercent = readDoubleMax();
                }

                if (version >= 14) {
                	order.m_basisPoints = readDoubleMax();
                	order.m_basisPointsType = readIntMax();
                	contract.m_comboLegsDescrip = readStr();
                }

                if (version >= 29) {
                	int comboLegsCount = readInt();
                	if (comboLegsCount > 0) {
                		contract.m_comboLegs = new Vector<ComboLeg>(comboLegsCount);
                		for (int i = 0; i < comboLegsCount; ++i) {
                			int conId = readInt();
                			int ratio = readInt();
                			String action = readStr();
                			String exchange = readStr();
                			int openClose = readInt();
                			int shortSaleSlot = readInt();
                			String designatedLocation = readStr();
                			int exemptCode = readInt();

                			ComboLeg comboLeg = new ComboLeg(conId, ratio, action, exchange, openClose,
                					shortSaleSlot, designatedLocation, exemptCode);
                			contract.m_comboLegs.add(comboLeg);
                		}
                	}

                	int orderComboLegsCount = readInt();
                	if (orderComboLegsCount > 0) {
                		order.m_orderComboLegs = new Vector<OrderComboLeg>(orderComboLegsCount);
                		for (int i = 0; i < orderComboLegsCount; ++i) {
                			double price = readDoubleMax();

                			OrderComboLeg orderComboLeg = new OrderComboLeg(price);
                			order.m_orderComboLegs.add(orderComboLeg);
                		}
                	}
                }

                if (version >= 26) {
                	int smartComboRoutingParamsCount = readInt();
                	if (smartComboRoutingParamsCount > 0) {
                		order.m_smartComboRoutingParams = new Vector<TagValue>(smartComboRoutingParamsCount);
                		for (int i = 0; i < smartComboRoutingParamsCount; ++i) {
                			TagValue tagValue = new TagValue();
                			tagValue.m_tag = readStr();
                			tagValue.m_value = readStr();
                			order.m_smartComboRoutingParams.add(tagValue);
                		}
                	}
                }

                if (version >= 15) {
                	if (version >= 20) {
                		order.m_scaleInitLevelSize = readIntMax();
                		order.m_scaleSubsLevelSize = readIntMax();
                	}
                	else {
                		/* int notSuppScaleNumComponents = */ readIntMax();
                		order.m_scaleInitLevelSize = readIntMax();
                	}
                	order.m_scalePriceIncrement = readDoubleMax();
                }

                if (version >= 28 && order.m_scalePriceIncrement > 0.0 && order.m_scalePriceIncrement != Double.MAX_VALUE) {
                    order.m_scalePriceAdjustValue = readDoubleMax();
                    order.m_scalePriceAdjustInterval = readIntMax();
                    order.m_scaleProfitOffset = readDoubleMax();
                    order.m_scaleAutoReset = readBoolFromInt();
                    order.m_scaleInitPosition = readIntMax();
                    order.m_scaleInitFillQty = readIntMax();
                    order.m_scaleRandomPercent = readBoolFromInt();
                }

                if (version >= 24) {
                	order.m_hedgeType = readStr();
                	if (!Util.StringIsEmpty(order.m_hedgeType)) {
                		order.m_hedgeParam = readStr();
                	}
                }

                if (version >= 25) {
                	order.m_optOutSmartRouting = readBoolFromInt();
                }

                if (version >= 19) {
                	order.m_clearingAccount = readStr();
                	order.m_clearingIntent = readStr();
                }

                if (version >= 22) {
                	order.m_notHeld = readBoolFromInt();
                }

                if (version >= 20) {
                    if (readBoolFromInt()) {
                        UnderComp underComp = new UnderComp();
                        underComp.m_conId = readInt();
                        underComp.m_delta = readDouble();
                        underComp.m_price = readDouble();
                        contract.m_underComp = underComp;
                    }
                }

                if (version >= 21) {
                	order.m_algoStrategy = readStr();
                	if (!Util.StringIsEmpty(order.m_algoStrategy)) {
                		int algoParamsCount = readInt();
                		if (algoParamsCount > 0) {
                			order.m_algoParams = new Vector<TagValue>(algoParamsCount);
                			for (int i = 0; i < algoParamsCount; ++i) {
                				TagValue tagValue = new TagValue();
                				tagValue.m_tag = readStr();
                				tagValue.m_value = readStr();
                				order.m_algoParams.add(tagValue);
                			}
                		}
                	}
                }

                OrderState orderState = new OrderState();

                if (version >= 16) {

                	order.m_whatIf = readBoolFromInt();

                	orderState.m_status = readStr();
                	orderState.m_initMargin = readStr();
                	orderState.m_maintMargin = readStr();
                	orderState.m_equityWithLoan = readStr();
                	orderState.m_commission = readDoubleMax();
                	orderState.m_minCommission = readDoubleMax();
                	orderState.m_maxCommission = readDoubleMax();
                	orderState.m_commissionCurrency = readStr();
                	orderState.m_warningText = readStr();
                }

                eWrapper().openOrder( order.m_orderId, contract, order, orderState);
                break;
            }

            case NEXT_VALID_ID: {
                int version = readInt();
                int orderId = readInt();
                eWrapper().nextValidId( orderId);
                break;
            }

            case SCANNER_DATA: {
                ContractDetails contract = new ContractDetails();
                int version = readInt();
                int tickerId = readInt();
                int numberOfElements = readInt();
                for (int ctr=0; ctr < numberOfElements; ctr++) {
                    int rank = readInt();
                    if (version >= 3) {
                    	contract.m_summary.m_conId = readInt();
                    }
                    contract.m_summary.m_symbol = readStr();
                    contract.m_summary.m_secType = readStr();
                    contract.m_summary.m_expiry = readStr();
                    contract.m_summary.m_strike = readDouble();
                    contract.m_summary.m_right = readStr();
                    contract.m_summary.m_exchange = readStr();
                    contract.m_summary.m_currency = readStr();
                    contract.m_summary.m_localSymbol = readStr();
                    contract.m_marketName = readStr();
                    contract.m_summary.m_tradingClass = readStr();
                    String distance = readStr();
                    String benchmark = readStr();
                    String projection = readStr();
                    String legsStr = null;
                    if (version >= 2) {
                    	legsStr = readStr();
                    }
                    eWrapper().scannerData(tickerId, rank, contract, distance,
                        benchmark, projection, legsStr);
                }
                eWrapper().scannerDataEnd(tickerId);
                break;
            }

            case CONTRACT_DATA: {
                int version = readInt();

                int reqId = -1;
                if (version >= 3) {
                	reqId = readInt();
                }

                ContractDetails contract = new ContractDetails();
                contract.m_summary.m_symbol = readStr();
                contract.m_summary.m_secType = readStr();
                contract.m_summary.m_expiry = readStr();
                contract.m_summary.m_strike = readDouble();
                contract.m_summary.m_right = readStr();
                contract.m_summary.m_exchange = readStr();
                contract.m_summary.m_currency = readStr();
                contract.m_summary.m_localSymbol = readStr();
                contract.m_marketName = readStr();
                contract.m_summary.m_tradingClass = readStr();
                contract.m_summary.m_conId = readInt();
                contract.m_minTick = readDouble();
                contract.m_summary.m_multiplier = readStr();
                contract.m_orderTypes = readStr();
                contract.m_validExchanges = readStr();
                if (version >= 2) {
                    contract.m_priceMagnifier = readInt();
                }
                if (version >= 4) {
                	contract.m_underConId = readInt();
                }
                if( version >= 5) {
                   contract.m_longName = readStr();
                   contract.m_summary.m_primaryExch = readStr();
                }
                if( version >= 6) {
                    contract.m_contractMonth = readStr();
                    contract.m_industry = readStr();
                    contract.m_category = readStr();
                    contract.m_subcategory = readStr();
                    contract.m_timeZoneId = readStr();
                    contract.m_tradingHours = readStr();
                    contract.m_liquidHours = readStr();
                 }
                if (version >= 8) {
                    contract.m_evRule = readStr();
                    contract.m_evMultiplier = readDouble();
                }
                if (version >= 7) {
                    int secIdListCount = readInt();
                        if (secIdListCount  > 0) {
                            contract.m_secIdList = new Vector<TagValue>(secIdListCount);
                            for (int i = 0; i < secIdListCount; ++i) {
                                TagValue tagValue = new TagValue();
                                tagValue.m_tag = readStr();
                                tagValue.m_value = readStr();
                                contract.m_secIdList.add(tagValue);
                            }
                        }
                }

                eWrapper().contractDetails( reqId, contract);
                break;
            }
            case BOND_CONTRACT_DATA: {
                int version = readInt();

                int reqId = -1;
                if (version >= 3) {
                	reqId = readInt();
                }

                ContractDetails contract = new ContractDetails();

                contract.m_summary.m_symbol = readStr();
                contract.m_summary.m_secType = readStr();
                contract.m_cusip = readStr();
                contract.m_coupon = readDouble();
                contract.m_maturity = readStr();
                contract.m_issueDate  = readStr();
                contract.m_ratings = readStr();
                contract.m_bondType = readStr();
                contract.m_couponType = readStr();
                contract.m_convertible = readBoolFromInt();
                contract.m_callable = readBoolFromInt();
                contract.m_putable = readBoolFromInt();
                contract.m_descAppend = readStr();
                contract.m_summary.m_exchange = readStr();
                contract.m_summary.m_currency = readStr();
                contract.m_marketName = readStr();
                contract.m_summary.m_tradingClass = readStr();
                contract.m_summary.m_conId = readInt();
                contract.m_minTick = readDouble();
                contract.m_orderTypes = readStr();
                contract.m_validExchanges = readStr();
                if (version >= 2) {
                	contract.m_nextOptionDate = readStr();
                	contract.m_nextOptionType = readStr();
                	contract.m_nextOptionPartial = readBoolFromInt();
                	contract.m_notes = readStr();
                }
                if( version >= 4) {
                   contract.m_longName = readStr();
                }
                if ( version >= 6) {
                    contract.m_evRule = readStr();
                    contract.m_evMultiplier = readDouble();
                }
                if (version >= 5) {
                    int secIdListCount = readInt();
                        if (secIdListCount  > 0) {
                            contract.m_secIdList = new Vector<TagValue>(secIdListCount);
                            for (int i = 0; i < secIdListCount; ++i) {
                                TagValue tagValue = new TagValue();
                                tagValue.m_tag = readStr();
                                tagValue.m_value = readStr();
                                contract.m_secIdList.add(tagValue);
                            }
                        }
                }

                eWrapper().bondContractDetails( reqId, contract);
                break;
            }
            case EXECUTION_DATA: {
                int version = readInt();

                int reqId = -1;
                if (version >= 7) {
                	reqId = readInt();
                }

                int orderId = readInt();

                // read contract fields
                Contract contract = new Contract();
                if (version >= 5) {
                	contract.m_conId = readInt();
                }
                contract.m_symbol = readStr();
                contract.m_secType = readStr();
                contract.m_expiry = readStr();
                contract.m_strike = readDouble();
                contract.m_right = readStr();
                if (version >= 9) {
                    contract.m_multiplier = readStr();
                }
                contract.m_exchange = readStr();
                contract.m_currency = readStr();
                contract.m_localSymbol = readStr();
                if (version >= 10) {
                    contract.m_tradingClass = readStr();
                }

                Execution exec = new Execution();
                exec.m_orderId = orderId;
                exec.m_execId = readStr();
                exec.m_time = readStr();
                exec.m_acctNumber = readStr();
                exec.m_exchange = readStr();
                exec.m_side = readStr();
                exec.m_shares = readInt();
                exec.m_price = readDouble();
                if ( version >= 2 ) {
                    exec.m_permId = readInt();
                }
                if ( version >= 3) {
                    exec.m_clientId = readInt();
                }
                if ( version >= 4) {
                    exec.m_liquidation = readInt();
                }
                if (version >= 6) {
                	exec.m_cumQty = readInt();
                	exec.m_avgPrice = readDouble();
                }
                if (version >= 8) {
                    exec.m_orderRef = readStr();
                }
                if (version >= 9) {
                    exec.m_evRule = readStr();
                    exec.m_evMultiplier = readDouble();
                }

                eWrapper().execDetails( reqId, contract, exec);
                break;
            }
            case MARKET_DEPTH: {
                int version = readInt();
                int id = readInt();

                int position = readInt();
                int operation = readInt();
                int side = readInt();
                double price = readDouble();
                int size = readInt();

                eWrapper().updateMktDepth(id, position, operation,
                                side, price, size);
                break;
            }
            case MARKET_DEPTH_L2: {
                int version = readInt();
                int id = readInt();

                int position = readInt();
                String marketMaker = readStr();
                int operation = readInt();
                int side = readInt();
                double price = readDouble();
                int size = readInt();

                eWrapper().updateMktDepthL2(id, position, marketMaker,
                                operation, side, price, size);
                break;
            }
            case NEWS_BULLETINS: {
                int version = readInt();
                int newsMsgId = readInt();
                int newsMsgType = readInt();
                String newsMessage = readStr();
                String originatingExch = readStr();

                eWrapper().updateNewsBulletin( newsMsgId, newsMsgType, newsMessage, originatingExch);
                break;
            }
            case MANAGED_ACCTS: {
                int version = readInt();
                String accountsList = readStr();

                eWrapper().managedAccounts( accountsList);
                break;
            }
            case RECEIVE_FA: {
              int version = readInt();
              int faDataType = readInt();
              String xml = readStr();

              eWrapper().receiveFA(faDataType, xml);
              break;
            }
            case HISTORICAL_DATA: {
              int version = readInt();
              int reqId = readInt();
        	  String startDateStr;
        	  String endDateStr;
        	  String completedIndicator = "finished";
              if (version >= 2) {
            	  startDateStr = readStr();
            	  endDateStr = readStr();
            	  completedIndicator += "-" + startDateStr + "-" + endDateStr;
              }
              int itemCount = readInt();
              for (int ctr = 0; ctr < itemCount; ctr++) {
                String date = readStr();
                double open = readDouble();
                double high = readDouble();
                double low = readDouble();
                double close = readDouble();
                int volume = readInt();
                double WAP = readDouble();
                String hasGaps = readStr();
                int barCount = -1;
                if (version >= 3) {
                	barCount = readInt();
                }
                eWrapper().historicalData(reqId, date, open, high, low,
                                        close, volume, barCount, WAP,
                                        Boolean.valueOf(hasGaps).booleanValue());
              }
              // send end of dataset marker
              eWrapper().historicalData(reqId, completedIndicator, -1, -1, -1, -1, -1, -1, -1, false);
              break;
            }
            case SCANNER_PARAMETERS: {
                int version = readInt();
                String xml = readStr();
                eWrapper().scannerParameters(xml);
                break;
            }
            case CURRENT_TIME: {
                /*int version =*/ readInt();
                long time = readLong();
                eWrapper().currentTime(time);
                break;
            }
            case REAL_TIME_BARS: {
                /*int version =*/ readInt();
                int reqId = readInt();
                long time = readLong();
                double open = readDouble();
                double high = readDouble();
                double low = readDouble();
                double close = readDouble();
                long volume = readLong();
                double wap = readDouble();
                int count = readInt();
                eWrapper().realtimeBar(reqId, time, open, high, low, close, volume, wap, count);
                break;
            }
            case FUNDAMENTAL_DATA: {
                /*int version =*/ readInt();
                int reqId = readInt();
                String data = readStr();
                eWrapper().fundamentalData(reqId, data);
                break;
            }
            case CONTRACT_DATA_END: {
                /*int version =*/ readInt();
                int reqId = readInt();
                eWrapper().contractDetailsEnd(reqId);
                break;
            }
            case OPEN_ORDER_END: {
                /*int version =*/ readInt();
                eWrapper().openOrderEnd();
                break;
            }
            case ACCT_DOWNLOAD_END: {
                /*int version =*/ readInt();
                String accountName = readStr();
                eWrapper().accountDownloadEnd( accountName);
                break;
            }
            case EXECUTION_DATA_END: {
                /*int version =*/ readInt();
                int reqId = readInt();
                eWrapper().execDetailsEnd( reqId);
                break;
            }
            case DELTA_NEUTRAL_VALIDATION: {
                /*int version =*/ readInt();
                int reqId = readInt();

                UnderComp underComp = new UnderComp();
                underComp.m_conId = readInt();
                underComp.m_delta = readDouble();
                underComp.m_price = readDouble();

                eWrapper().deltaNeutralValidation( reqId, underComp);
                break;
            }
            case TICK_SNAPSHOT_END: {
                /*int version =*/ readInt();
                int reqId = readInt();

                eWrapper().tickSnapshotEnd( reqId);
                break;
            }
            case MARKET_DATA_TYPE: {
                /*int version =*/ readInt();
                int reqId = readInt();
                int marketDataType = readInt();

                eWrapper().marketDataType( reqId, marketDataType);
                break;
            }
            case COMMISSION_REPORT: {
                /*int version =*/ readInt();

                CommissionReport commissionReport = new CommissionReport();
                commissionReport.m_execId = readStr();
                commissionReport.m_commission = readDouble();
                commissionReport.m_currency = readStr();
                commissionReport.m_realizedPNL = readDouble();
                commissionReport.m_yield = readDouble();
                commissionReport.m_yieldRedemptionDate = readInt();

                eWrapper().commissionReport( commissionReport);
                break;
            }
            case VERIFY_MESSAGE_API: {
                /*int version =*/ readInt();
                String apiData = readStr();

                eWrapper().verifyMessageAPI(apiData);
                break;
            }
            case VERIFY_COMPLETED: {
                /*int version =*/ readInt();
                String isSuccessfulStr = readStr();
                boolean isSuccessful = "true".equals(isSuccessfulStr);
                String errorText = readStr();


                if (isSuccessful) {
                    m_parent.startAPI();
                }

                eWrapper().verifyCompleted(isSuccessful, errorText);
                break;
            }
            case DISPLAY_GROUP_LIST: {
                /*int version =*/ readInt();
                int reqId = readInt();
                String groups = readStr();

                eWrapper().displayGroupList(reqId, groups);
                break;
            }
            case DISPLAY_GROUP_UPDATED: {
                /*int version =*/ readInt();
                int reqId = readInt();
                String contractInfo = readStr();

                eWrapper().displayGroupUpdated(reqId, contractInfo);
                break;
            }

            default: {
                m_parent.error( EClientErrors.NO_VALID_ID, EClientErrors.UNKNOWN_ID.code(), EClientErrors.UNKNOWN_ID.msg());
                return false;
            }
        }
        return true;
    }


    protected String readStr() throws IOException {
        StringBuffer buf = new StringBuffer();
        while( true) {
            byte c = m_dis.readByte();
            if( c == 0) {
                break;
            }
            buf.append( (char)c);
        }

        String str = buf.toString();
        return str.length() == 0 ? null : str;
    }


    boolean readBoolFromInt() throws IOException {
        String str = readStr();
        return str == null ? false : (Integer.parseInt( str) != 0);
    }

    protected int readInt() throws IOException {
        String str = readStr();
        return str == null ? 0 : Integer.parseInt( str);
    }

    protected int readIntMax() throws IOException {
        String str = readStr();
        return (str == null || str.length() == 0) ? Integer.MAX_VALUE
        	                                      : Integer.parseInt( str);
    }

    protected long readLong() throws IOException {
        String str = readStr();
        return str == null ? 0l : Long.parseLong(str);
    }

    protected double readDouble() throws IOException {
        String str = readStr();
        return str == null ? 0 : Double.parseDouble( str);
    }

    protected double readDoubleMax() throws IOException {
        String str = readStr();
        return (str == null || str.length() == 0) ? Double.MAX_VALUE
        	                                      : Double.parseDouble( str);
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/EWrapper.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public interface EWrapper extends AnyWrapper {

    ///////////////////////////////////////////////////////////////////////
    // Interface methods
    ///////////////////////////////////////////////////////////////////////
    void tickPrice( int tickerId, int field, double price, int canAutoExecute);
    void tickSize( int tickerId, int field, int size);
    void tickOptionComputation( int tickerId, int field, double impliedVol,
    		double delta, double optPrice, double pvDividend,
    		double gamma, double vega, double theta, double undPrice);
	void tickGeneric(int tickerId, int tickType, double value);
	void tickString(int tickerId, int tickType, String value);
	void tickEFP(int tickerId, int tickType, double basisPoints,
			String formattedBasisPoints, double impliedFuture, int holdDays,
			String futureExpiry, double dividendImpact, double dividendsToExpiry);
    void orderStatus( int orderId, String status, int filled, int remaining,
            double avgFillPrice, int permId, int parentId, double lastFillPrice,
            int clientId, String whyHeld);
    void openOrder( int orderId, Contract contract, Order order, OrderState orderState);
    void openOrderEnd();
    void updateAccountValue(String key, String value, String currency, String accountName);
    void updatePortfolio(Contract contract, int position, double marketPrice, double marketValue,
            double averageCost, double unrealizedPNL, double realizedPNL, String accountName);
    void updateAccountTime(String timeStamp);
    void accountDownloadEnd(String accountName);
    void nextValidId( int orderId);
    void contractDetails(int reqId, ContractDetails contractDetails);
    void bondContractDetails(int reqId, ContractDetails contractDetails);
    void contractDetailsEnd(int reqId);
    void execDetails( int reqId, Contract contract, Execution execution);
    void execDetailsEnd( int reqId);
    void updateMktDepth( int tickerId, int position, int operation, int side, double price, int size);
    void updateMktDepthL2( int tickerId, int position, String marketMaker, int operation,
    		int side, double price, int size);
    void updateNewsBulletin( int msgId, int msgType, String message, String origExchange);
    void managedAccounts( String accountsList);
    void receiveFA(int faDataType, String xml);
    void historicalData(int reqId, String date, double open, double high, double low,
                      double close, int volume, int count, double WAP, boolean hasGaps);
    void scannerParameters(String xml);
    void scannerData(int reqId, int rank, ContractDetails contractDetails, String distance,
    		String benchmark, String projection, String legsStr);
    void scannerDataEnd(int reqId);
    void realtimeBar(int reqId, long time, double open, double high, double low, double close, long volume, double wap, int count);
    void currentTime(long time);
    void fundamentalData(int reqId, String data);
    void deltaNeutralValidation(int reqId, UnderComp underComp);
    void tickSnapshotEnd(int reqId);
    void marketDataType(int reqId, int marketDataType);
    void commissionReport(CommissionReport commissionReport);
    void position(String account, Contract contract, int pos, double avgCost);
    void positionEnd();
    void accountSummary(int reqId, String account, String tag, String value, String currency);
    void accountSummaryEnd(int reqId);
    void verifyMessageAPI( String apiData);
    void verifyCompleted( boolean isSuccessful, String errorText);
    void displayGroupList( int reqId, String groups);
    void displayGroupUpdated( int reqId, String contractInfo);
}

/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/EWrapperMsgGenerator.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.text.DateFormat;
import java.util.Date;
import java.util.Vector;

public class EWrapperMsgGenerator extends AnyWrapperMsgGenerator {
    public static final String SCANNER_PARAMETERS = "SCANNER PARAMETERS:";
    public static final String FINANCIAL_ADVISOR = "FA:";
    
	static public String tickPrice( int tickerId, int field, double price, int canAutoExecute) {
    	return "id=" + tickerId + "  " + TickType.getField( field) + "=" + price + " " + 
        ((canAutoExecute != 0) ? " canAutoExecute" : " noAutoExecute");
    }
	
    static public String tickSize( int tickerId, int field, int size) {
    	return "id=" + tickerId + "  " + TickType.getField( field) + "=" + size;
    }
    
    static public String tickOptionComputation( int tickerId, int field, double impliedVol,
    		double delta, double optPrice, double pvDividend,
    		double gamma, double vega, double theta, double undPrice) {
    	String toAdd = "id=" + tickerId + "  " + TickType.getField( field) +
    		": vol = " + ((impliedVol >= 0 && impliedVol != Double.MAX_VALUE) ? Double.toString(impliedVol) : "N/A") +
    		" delta = " + ((Math.abs(delta) <= 1) ? Double.toString(delta) : "N/A") +
    		" gamma = " + ((Math.abs(gamma) <= 1) ? Double.toString(gamma) : "N/A") +
    		" vega = " + ((Math.abs(vega) <= 1) ? Double.toString(vega) : "N/A") +
    		" theta = " + ((Math.abs(theta) <= 1) ? Double.toString(theta) : "N/A") +
    		" optPrice = " + ((optPrice >= 0 && optPrice != Double.MAX_VALUE) ? Double.toString(optPrice) : "N/A") +
    		" pvDividend = " + ((pvDividend >= 0 && pvDividend != Double.MAX_VALUE) ? Double.toString(pvDividend) : "N/A") +
    		" undPrice = " + ((undPrice >= 0 && undPrice != Double.MAX_VALUE) ? Double.toString(undPrice) : "N/A");
		return toAdd;
    }
    
    static public String tickGeneric(int tickerId, int tickType, double value) {
    	return "id=" + tickerId + "  " + TickType.getField( tickType) + "=" + value;
    }
    
    static public String tickString(int tickerId, int tickType, String value) {
    	return "id=" + tickerId + "  " + TickType.getField( tickType) + "=" + value;
    }
    
    static public String tickEFP(int tickerId, int tickType, double basisPoints,
			String formattedBasisPoints, double impliedFuture, int holdDays,
			String futureExpiry, double dividendImpact, double dividendsToExpiry) {
    	return "id=" + tickerId + "  " + TickType.getField(tickType)
		+ ": basisPoints = " + basisPoints + "/" + formattedBasisPoints
		+ " impliedFuture = " + impliedFuture + " holdDays = " + holdDays +
		" futureExpiry = " + futureExpiry + " dividendImpact = " + dividendImpact +
		" dividends to expiry = "	+ dividendsToExpiry;
    }
    
    static public String orderStatus( int orderId, String status, int filled, int remaining,
            double avgFillPrice, int permId, int parentId, double lastFillPrice,
            int clientId, String whyHeld) {
    	return "order status: orderId=" + orderId + " clientId=" + clientId + " permId=" + permId +
        " status=" + status + " filled=" + filled + " remaining=" + remaining +
        " avgFillPrice=" + avgFillPrice + " lastFillPrice=" + lastFillPrice +
        " parent Id=" + parentId + " whyHeld=" + whyHeld;
    }
    
    static public String openOrder( int orderId, Contract contract, Order order, OrderState orderState) {
        String msg = "open order: orderId=" + orderId +
        " action=" + order.m_action +
        " quantity=" + order.m_totalQuantity +
        " conid=" + contract.m_conId + 
        " symbol=" + contract.m_symbol + 
        " secType=" + contract.m_secType + 
        " expiry=" + contract.m_expiry + 
        " strike=" + contract.m_strike + 
        " right=" + contract.m_right + 
        " multiplier=" + contract.m_multiplier + 
        " exchange=" + contract.m_exchange + 
        " primaryExch=" + contract.m_primaryExch + 
        " currency=" + contract.m_currency + 
        " localSymbol=" + contract.m_localSymbol + 
        " tradingClass=" + contract.m_tradingClass + 
        " type=" + order.m_orderType +
        " lmtPrice=" + Util.DoubleMaxString(order.m_lmtPrice) +
        " auxPrice=" + Util.DoubleMaxString(order.m_auxPrice) +
        " TIF=" + order.m_tif +
        " localSymbol=" + contract.m_localSymbol +
        " client Id=" + order.m_clientId +
        " parent Id=" + order.m_parentId +
        " permId=" + order.m_permId +
        " outsideRth=" + order.m_outsideRth +
        " hidden=" + order.m_hidden +
        " discretionaryAmt=" + order.m_discretionaryAmt +
        " displaySize=" + order.m_displaySize +
        " triggerMethod=" + order.m_triggerMethod +
        " goodAfterTime=" + order.m_goodAfterTime +
        " goodTillDate=" + order.m_goodTillDate +
        " faGroup=" + order.m_faGroup +
        " faMethod=" + order.m_faMethod +
        " faPercentage=" + order.m_faPercentage +
        " faProfile=" + order.m_faProfile +
        " shortSaleSlot=" + order.m_shortSaleSlot +
        " designatedLocation=" + order.m_designatedLocation +
        " exemptCode=" + order.m_exemptCode +
        " ocaGroup=" + order.m_ocaGroup +
        " ocaType=" + order.m_ocaType +
        " rule80A=" + order.m_rule80A +
        " allOrNone=" + order.m_allOrNone +
        " minQty=" + Util.IntMaxString(order.m_minQty) +
        " percentOffset=" + Util.DoubleMaxString(order.m_percentOffset) +
        " eTradeOnly=" + order.m_eTradeOnly +
        " firmQuoteOnly=" + order.m_firmQuoteOnly +
        " nbboPriceCap=" + Util.DoubleMaxString(order.m_nbboPriceCap) +
        " optOutSmartRouting=" + order.m_optOutSmartRouting +
        " auctionStrategy=" + order.m_auctionStrategy +
        " startingPrice=" + Util.DoubleMaxString(order.m_startingPrice) +
        " stockRefPrice=" + Util.DoubleMaxString(order.m_stockRefPrice) +
        " delta=" + Util.DoubleMaxString(order.m_delta) +
        " stockRangeLower=" + Util.DoubleMaxString(order.m_stockRangeLower) +
        " stockRangeUpper=" + Util.DoubleMaxString(order.m_stockRangeUpper) +
        " volatility=" + Util.DoubleMaxString(order.m_volatility) +
        " volatilityType=" + order.m_volatilityType +
        " deltaNeutralOrderType=" + order.m_deltaNeutralOrderType +
        " deltaNeutralAuxPrice=" + Util.DoubleMaxString(order.m_deltaNeutralAuxPrice) +
        " deltaNeutralConId=" + order.m_deltaNeutralConId +
        " deltaNeutralSettlingFirm=" + order.m_deltaNeutralSettlingFirm +
        " deltaNeutralClearingAccount=" + order.m_deltaNeutralClearingAccount +
        " deltaNeutralClearingIntent=" + order.m_deltaNeutralClearingIntent +
        " deltaNeutralOpenClose=" + order.m_deltaNeutralOpenClose +
        " deltaNeutralShortSale=" + order.m_deltaNeutralShortSale +
        " deltaNeutralShortSaleSlot=" + order.m_deltaNeutralShortSaleSlot +
        " deltaNeutralDesignatedLocation=" + order.m_deltaNeutralDesignatedLocation +
        " continuousUpdate=" + order.m_continuousUpdate +
        " referencePriceType=" + order.m_referencePriceType +
        " trailStopPrice=" + Util.DoubleMaxString(order.m_trailStopPrice) +
        " trailingPercent=" + Util.DoubleMaxString(order.m_trailingPercent) +
        " scaleInitLevelSize=" + Util.IntMaxString(order.m_scaleInitLevelSize) +
        " scaleSubsLevelSize=" + Util.IntMaxString(order.m_scaleSubsLevelSize) +
        " scalePriceIncrement=" + Util.DoubleMaxString(order.m_scalePriceIncrement) +
        " scalePriceAdjustValue=" + Util.DoubleMaxString(order.m_scalePriceAdjustValue) +
        " scalePriceAdjustInterval=" + Util.IntMaxString(order.m_scalePriceAdjustInterval) +
        " scaleProfitOffset=" + Util.DoubleMaxString(order.m_scaleProfitOffset) +
        " scaleAutoReset=" + order.m_scaleAutoReset +
        " scaleInitPosition=" + Util.IntMaxString(order.m_scaleInitPosition) +
        " scaleInitFillQty=" + Util.IntMaxString(order.m_scaleInitFillQty) +
        " scaleRandomPercent=" + order.m_scaleRandomPercent +
        " hedgeType=" + order.m_hedgeType +
        " hedgeParam=" + order.m_hedgeParam +
        " account=" + order.m_account +
        " settlingFirm=" + order.m_settlingFirm +
        " clearingAccount=" + order.m_clearingAccount +
        " clearingIntent=" + order.m_clearingIntent +
        " notHeld=" + order.m_notHeld +
        " whatIf=" + order.m_whatIf
        ;

        if ("BAG".equals(contract.m_secType)) {
        	if (contract.m_comboLegsDescrip != null) {
        		msg += " comboLegsDescrip=" + contract.m_comboLegsDescrip;
        	}
        	
           	msg += " comboLegs={";
            if (contract.m_comboLegs != null) {
            	for (int i = 0; i < contract.m_comboLegs.size(); ++i) {
            		ComboLeg comboLeg = contract.m_comboLegs.get(i);
            		msg += " leg " + (i+1) + ": "; 
            		msg += "conId=" +  comboLeg.m_conId;
            		msg += " ratio=" +  comboLeg.m_ratio;
            		msg += " action=" +  comboLeg.m_action;
            		msg += " exchange=" +  comboLeg.m_exchange;
            		msg += " openClose=" +  comboLeg.m_openClose;
            		msg += " shortSaleSlot=" +  comboLeg.m_shortSaleSlot;
            		msg += " designatedLocation=" +  comboLeg.m_designatedLocation;
            		msg += " exemptCode=" +  comboLeg.m_exemptCode;
            		if (order.m_orderComboLegs != null && contract.m_comboLegs.size() == order.m_orderComboLegs.size()) {
            			OrderComboLeg orderComboLeg = order.m_orderComboLegs.get(i);
            			msg += " price=" +  Util.DoubleMaxString(orderComboLeg.m_price);
            		}
            		msg += ";";
            	}
            }
           	msg += "}";
           	
        	if (order.m_basisPoints != Double.MAX_VALUE) {
        		msg += " basisPoints=" + Util.DoubleMaxString(order.m_basisPoints);
        		msg += " basisPointsType=" + Util.IntMaxString(order.m_basisPointsType);
        	}
        }
        
    	if (contract.m_underComp != null) {
    		UnderComp underComp = contract.m_underComp;
    		msg +=
    			" underComp.conId =" + underComp.m_conId +
    			" underComp.delta =" + underComp.m_delta +
    			" underComp.price =" + underComp.m_price ;
    	}
    	
    	if (!Util.StringIsEmpty(order.m_algoStrategy)) {
    		msg += " algoStrategy=" + order.m_algoStrategy;
    		msg += " algoParams={";
    		if (order.m_algoParams != null) {
    			Vector algoParams = order.m_algoParams;
    			for (int i = 0; i < algoParams.size(); ++i) {
    				TagValue param = (TagValue)algoParams.elementAt(i);
    				if (i > 0) {
    					msg += ",";
    				}
    				msg += param.m_tag + "=" + param.m_value;
    			}
    		}
    		msg += "}";
    	}
    	
        if ("BAG".equals(contract.m_secType)) {
        	msg += " smartComboRoutingParams={";
        	if (order.m_smartComboRoutingParams != null) {
        		Vector smartComboRoutingParams = order.m_smartComboRoutingParams;
        		for (int i = 0; i < smartComboRoutingParams.size(); ++i) {
        			TagValue param = (TagValue)smartComboRoutingParams.elementAt(i);
        			if (i > 0) {
        				msg += ",";
        			}
        			msg += param.m_tag + "=" + param.m_value;
        		}
        	}
        	msg += "}";
        }
    
        String orderStateMsg =
        	" status=" + orderState.m_status
        	+ " initMargin=" + orderState.m_initMargin
        	+ " maintMargin=" + orderState.m_maintMargin
        	+ " equityWithLoan=" + orderState.m_equityWithLoan
        	+ " commission=" + Util.DoubleMaxString(orderState.m_commission)
        	+ " minCommission=" + Util.DoubleMaxString(orderState.m_minCommission)
        	+ " maxCommission=" + Util.DoubleMaxString(orderState.m_maxCommission)
        	+ " commissionCurrency=" + orderState.m_commissionCurrency
        	+ " warningText=" + orderState.m_warningText
		;

        return msg + orderStateMsg;
    }
    
    static public String openOrderEnd() {
    	return " =============== end ===============";
    }
    
    static public String updateAccountValue(String key, String value, String currency, String accountName) {
    	return "updateAccountValue: " + key + " " + value + " " + currency + " " + accountName;
    }
    
    static public String updatePortfolio(Contract contract, int position, double marketPrice,
    									 double marketValue, double averageCost, double unrealizedPNL,
    									 double realizedPNL, String accountName) {
    	String msg = "updatePortfolio: "
    		+ contractMsg(contract)
    		+ position + " " + marketPrice + " " + marketValue + " " + averageCost + " " + unrealizedPNL + " " + realizedPNL + " " + accountName;
    	return msg;
    }
    
    static public String updateAccountTime(String timeStamp) {
    	return "updateAccountTime: " + timeStamp;
    }
    
    static public String accountDownloadEnd(String accountName) {
    	return "accountDownloadEnd: " + accountName;
    }
    
    static public String nextValidId( int orderId) {
    	return "Next Valid Order ID: " + orderId;
    }
    
    static public String contractDetails(int reqId, ContractDetails contractDetails) {
    	Contract contract = contractDetails.m_summary;
    	String msg = "reqId = " + reqId + " ===================================\n"
    		+ " ---- Contract Details begin ----\n"
    		+ contractMsg(contract) + contractDetailsMsg(contractDetails)
    		+ " ---- Contract Details End ----\n";
    	return msg;
    }
    
    private static String contractDetailsMsg(ContractDetails contractDetails) {
    	String msg = "marketName = " + contractDetails.m_marketName + "\n"
        + "minTick = " + contractDetails.m_minTick + "\n"
        + "price magnifier = " + contractDetails.m_priceMagnifier + "\n"
        + "orderTypes = " + contractDetails.m_orderTypes + "\n"
        + "validExchanges = " + contractDetails.m_validExchanges + "\n"
        + "underConId = " + contractDetails.m_underConId + "\n"
        + "longName = " + contractDetails.m_longName + "\n"
        + "contractMonth = " + contractDetails.m_contractMonth + "\n"
        + "industry = " + contractDetails.m_industry + "\n"
        + "category = " + contractDetails.m_category + "\n"
        + "subcategory = " + contractDetails.m_subcategory + "\n"
        + "timeZoneId = " + contractDetails.m_timeZoneId + "\n"
        + "tradingHours = " + contractDetails.m_tradingHours + "\n"
        + "liquidHours = " + contractDetails.m_liquidHours + "\n"
        + "evRule = " + contractDetails.m_evRule + "\n"
        + "evMultiplier = " + contractDetails.m_evMultiplier + "\n"
        + contractDetailsSecIdList(contractDetails);
    	return msg;
    }
    
	static public String contractMsg(Contract contract) {
    	String msg = "conid = " + contract.m_conId + "\n"
        + "symbol = " + contract.m_symbol + "\n"
        + "secType = " + contract.m_secType + "\n"
        + "expiry = " + contract.m_expiry + "\n"
        + "strike = " + contract.m_strike + "\n"
        + "right = " + contract.m_right + "\n"
        + "multiplier = " + contract.m_multiplier + "\n"
        + "exchange = " + contract.m_exchange + "\n"
        + "primaryExch = " + contract.m_primaryExch + "\n"
        + "currency = " + contract.m_currency + "\n"
        + "localSymbol = " + contract.m_localSymbol + "\n"
        + "tradingClass = " + contract.m_tradingClass + "\n";
    	return msg;
    }
	
    static public String bondContractDetails(int reqId, ContractDetails contractDetails) {
        Contract contract = contractDetails.m_summary;
        String msg = "reqId = " + reqId + " ===================================\n"	
        + " ---- Bond Contract Details begin ----\n"
        + "symbol = " + contract.m_symbol + "\n"
        + "secType = " + contract.m_secType + "\n"
        + "cusip = " + contractDetails.m_cusip + "\n"
        + "coupon = " + contractDetails.m_coupon + "\n"
        + "maturity = " + contractDetails.m_maturity + "\n"
        + "issueDate = " + contractDetails.m_issueDate + "\n"
        + "ratings = " + contractDetails.m_ratings + "\n"
        + "bondType = " + contractDetails.m_bondType + "\n"
        + "couponType = " + contractDetails.m_couponType + "\n"
        + "convertible = " + contractDetails.m_convertible + "\n"
        + "callable = " + contractDetails.m_callable + "\n"
        + "putable = " + contractDetails.m_putable + "\n"
        + "descAppend = " + contractDetails.m_descAppend + "\n"
        + "exchange = " + contract.m_exchange + "\n"
        + "currency = " + contract.m_currency + "\n"
        + "marketName = " + contractDetails.m_marketName + "\n"
        + "tradingClass = " + contract.m_tradingClass + "\n"
        + "conid = " + contract.m_conId + "\n"
        + "minTick = " + contractDetails.m_minTick + "\n"
        + "orderTypes = " + contractDetails.m_orderTypes + "\n"
        + "validExchanges = " + contractDetails.m_validExchanges + "\n"
        + "nextOptionDate = " + contractDetails.m_nextOptionDate + "\n"
        + "nextOptionType = " + contractDetails.m_nextOptionType + "\n"
        + "nextOptionPartial = " + contractDetails.m_nextOptionPartial + "\n"
        + "notes = " + contractDetails.m_notes + "\n"
        + "longName = " + contractDetails.m_longName + "\n"
        + "evRule = " + contractDetails.m_evRule + "\n"
        + "evMultiplier = " + contractDetails.m_evMultiplier + "\n"
        + contractDetailsSecIdList(contractDetails)
        + " ---- Bond Contract Details End ----\n";
        return msg;
    }
    
    static public String contractDetailsSecIdList(ContractDetails contractDetails) {
        String msg = "secIdList={";
        if (contractDetails.m_secIdList != null) {
            Vector secIdList = contractDetails.m_secIdList;
            for (int i = 0; i < secIdList.size(); ++i) {
                TagValue param = (TagValue)secIdList.elementAt(i);
                if (i > 0) {
                    msg += ",";
                }
                msg += param.m_tag + "=" + param.m_value;
            }
        }
        msg += "}\n";
        return msg;
    }

    static public String contractDetailsEnd(int reqId) {
    	return "reqId = " + reqId + " =============== end ===============";
    }
    
    static public String execDetails( int reqId, Contract contract, Execution execution) {
        String msg = " ---- Execution Details begin ----\n"
        + "reqId = " + reqId + "\n"
        + "orderId = " + execution.m_orderId + "\n"
        + "clientId = " + execution.m_clientId + "\n"
        + contractMsg(contract)
        + "execId = " + execution.m_execId + "\n"
        + "time = " + execution.m_time + "\n"
        + "acctNumber = " + execution.m_acctNumber + "\n"
        + "executionExchange = " + execution.m_exchange + "\n"
        + "side = " + execution.m_side + "\n"
        + "shares = " + execution.m_shares + "\n"
        + "price = " + execution.m_price + "\n"
        + "permId = " + execution.m_permId + "\n"
        + "liquidation = " + execution.m_liquidation + "\n"
        + "cumQty = " + execution.m_cumQty + "\n"
        + "avgPrice = " + execution.m_avgPrice + "\n"
        + "orderRef = " + execution.m_orderRef + "\n"
        + "evRule = " + execution.m_evRule + "\n"
        + "evMultiplier = " + execution.m_evMultiplier + "\n"
        + " ---- Execution Details end ----\n";
        return msg;
    }
    
    static public String execDetailsEnd(int reqId) {
    	return "reqId = " + reqId + " =============== end ===============";
    }
    
    static public String updateMktDepth( int tickerId, int position, int operation, int side,
    									 double price, int size) {
    	return "updateMktDepth: " + tickerId + " " + position + " " + operation + " " + side + " " + price + " " + size;
    }
    
    static public String updateMktDepthL2( int tickerId, int position, String marketMaker,
    									   int operation, int side, double price, int size) {
    	return "updateMktDepth: " + tickerId + " " + position + " " + marketMaker + " " + operation + " " + side + " " + price + " " + size;
    }
    
    static public String updateNewsBulletin( int msgId, int msgType, String message, String origExchange) {
    	return "MsgId=" + msgId + " :: MsgType=" + msgType +  " :: Origin=" + origExchange + " :: Message=" + message;
    }
    
    static public String managedAccounts( String accountsList) {
    	return "Connected : The list of managed accounts are : [" + accountsList + "]";
    }
    
    static public String receiveFA(int faDataType, String xml) {
    	return FINANCIAL_ADVISOR + " " + EClientSocket.faMsgTypeName(faDataType) + " " + xml;
    }
    
    static public String historicalData(int reqId, String date, double open, double high, double low,
                      					double close, int volume, int count, double WAP, boolean hasGaps) {
    	return "id=" + reqId +
        " date = " + date +
        " open=" + open +
        " high=" + high +
        " low=" + low +
        " close=" + close +
        " volume=" + volume +
        " count=" + count +
        " WAP=" + WAP +
        " hasGaps=" + hasGaps;
    }
	public static String realtimeBar(int reqId, long time, double open,
			double high, double low, double close, long volume, double wap, int count) {
        return "id=" + reqId +
        " time = " + time +
        " open=" + open +
        " high=" + high +
        " low=" + low +
        " close=" + close +
        " volume=" + volume +
        " count=" + count +
        " WAP=" + wap;
	}
	
    static public String scannerParameters(String xml) {
    	return SCANNER_PARAMETERS + "\n" + xml;
    }
    
    static public String scannerData(int reqId, int rank, ContractDetails contractDetails,
    								 String distance, String benchmark, String projection,
    								 String legsStr) {
        Contract contract = contractDetails.m_summary;
    	return "id = " + reqId +
        " rank=" + rank +
        " symbol=" + contract.m_symbol +
        " secType=" + contract.m_secType +
        " expiry=" + contract.m_expiry +
        " strike=" + contract.m_strike +
        " right=" + contract.m_right +
        " exchange=" + contract.m_exchange +
        " currency=" + contract.m_currency +
        " localSymbol=" + contract.m_localSymbol +
        " marketName=" + contractDetails.m_marketName +
        " tradingClass=" + contract.m_tradingClass +
        " distance=" + distance +
        " benchmark=" + benchmark +
        " projection=" + projection +
        " legsStr=" + legsStr;
    }
    
    static public String scannerDataEnd(int reqId) {
    	return "id = " + reqId + " =============== end ===============";
    }
    
    static public String currentTime(long time) {
		return "current time = " + time +
		" (" + DateFormat.getDateTimeInstance().format(new Date(time * 1000)) + ")";
    }

    static public String fundamentalData(int reqId, String data) {
		return "id  = " + reqId + " len = " + data.length() + '\n' + data;
    }
    
    static public String deltaNeutralValidation(int reqId, UnderComp underComp) {
    	return "id = " + reqId
    	+ " underComp.conId =" + underComp.m_conId
    	+ " underComp.delta =" + underComp.m_delta
    	+ " underComp.price =" + underComp.m_price;
    }
    static public String tickSnapshotEnd(int tickerId) {
    	return "id=" + tickerId + " =============== end ===============";
    }
    
    static public String marketDataType(int reqId, int marketDataType){
    	return "id=" + reqId + " marketDataType = " + MarketDataType.getField(marketDataType);
    }
    
    static public String commissionReport( CommissionReport commissionReport) {
        String msg = "commission report:" +
        " execId=" + commissionReport.m_execId +
        " commission=" + Util.DoubleMaxString(commissionReport.m_commission) +
        " currency=" + commissionReport.m_currency +
        " realizedPNL=" + Util.DoubleMaxString(commissionReport.m_realizedPNL) +
        " yield=" + Util.DoubleMaxString(commissionReport.m_yield) +
        " yieldRedemptionDate=" + Util.IntMaxString(commissionReport.m_yieldRedemptionDate);
        return msg;
    }
    
    static public String position( String account, Contract contract, int position, double avgCost) {
        String msg = " ---- Position begin ----\n"
        + "account = " + account + "\n"
        + contractMsg(contract)
        + "position = " + Util.IntMaxString(position) + "\n"
        + "avgCost = " + Util.DoubleMaxString(avgCost) + "\n"
        + " ---- Position end ----\n";
        return msg;
    }    

    static public String positionEnd() {
        return " =============== end ===============";
    }

    static public String accountSummary( int reqId, String account, String tag, String value, String currency) {
        String msg = " ---- Account Summary begin ----\n"
        + "reqId = " + reqId + "\n"
        + "account = " + account + "\n"
        + "tag = " + tag + "\n"
        + "value = " + value + "\n"
        + "currency = " + currency + "\n"
        + " ---- Account Summary end ----\n";
        return msg;
    }

    static public String accountSummaryEnd( int reqId) {
    	return "id=" + reqId + " =============== end ===============";
    }

}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/Execution.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class Execution {
    public int 		m_orderId;
    public int 		m_clientId;
    public String 	m_execId;
    public String 	m_time;
    public String 	m_acctNumber;
    public String 	m_exchange;
    public String 	m_side;
    public int 		m_shares;
    public double 	m_price;
    public int		m_permId;
    public int         m_liquidation;
    public int		m_cumQty;
    public double	m_avgPrice;
    public String   m_orderRef;
    public String 	m_evRule;
    public double 	m_evMultiplier;

    public Execution() {
        m_orderId = 0;
        m_clientId = 0;
        m_shares = 0;
        m_price = 0;
        m_permId = 0;
        m_liquidation = 0;
        m_cumQty = 0;
        m_avgPrice = 0;
        m_evMultiplier = 0;
    }

    public Execution( int p_orderId, int p_clientId, String p_execId, String p_time,
                      String p_acctNumber, String p_exchange, String p_side, int p_shares,
                      double p_price, int p_permId, int p_liquidation, int p_cumQty,
                      double p_avgPrice, String p_orderRef, String p_evRule, double p_evMultiplier) {
        m_orderId = p_orderId;
        m_clientId = p_clientId;
        m_execId = p_execId;
        m_time = p_time;
      	m_acctNumber = p_acctNumber;
      	m_exchange = p_exchange;
      	m_side = p_side;
      	m_shares = p_shares;
      	m_price = p_price;
        m_permId = p_permId;
        m_liquidation = p_liquidation;
        m_cumQty = p_cumQty;
        m_avgPrice = p_avgPrice;
        m_orderRef = p_orderRef;
        m_evRule = p_evRule;
        m_evMultiplier = p_evMultiplier;
    }

    public boolean equals(Object p_other) {
        boolean l_bRetVal = false;

        if ( p_other == null ) {
            l_bRetVal = false;
		}
        else if ( this == p_other ) {
            l_bRetVal = true;
        }
        else {
            Execution l_theOther = (Execution)p_other;
            l_bRetVal = m_execId.equals( l_theOther.m_execId);
        }
        return l_bRetVal;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/ExecutionFilter.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class ExecutionFilter{
    public int 		m_clientId; // zero means no filtering on this field
    public String 	m_acctCode;
    public String 	m_time;
    public String 	m_symbol;
    public String 	m_secType;
    public String 	m_exchange;
    public String 	m_side;

    public ExecutionFilter() {
        m_clientId = 0;
    }

    public ExecutionFilter( int p_clientId, String p_acctCode, String p_time,
    		String p_symbol, String p_secType, String p_exchange, String p_side) {
        m_clientId = p_clientId;
        m_acctCode = p_acctCode;
        m_time = p_time;
        m_symbol = p_symbol;
        m_secType = p_secType;
        m_exchange = p_exchange;
        m_side = p_side;
    }

    public boolean equals(Object p_other) {
        boolean l_bRetVal = false;

        if ( p_other == null ) {
            l_bRetVal = false;
		}
        else if ( this == p_other ) {
            l_bRetVal = true;
        }
        else {
            ExecutionFilter l_theOther = (ExecutionFilter)p_other;
            l_bRetVal = (m_clientId == l_theOther.m_clientId &&
                    m_acctCode.equalsIgnoreCase( l_theOther.m_acctCode) &&
                    m_time.equalsIgnoreCase( l_theOther.m_time) &&
                    m_symbol.equalsIgnoreCase( l_theOther.m_symbol) &&
                    m_secType.equalsIgnoreCase( l_theOther.m_secType) &&
                    m_exchange.equalsIgnoreCase( l_theOther.m_exchange) &&
                    m_side.equalsIgnoreCase( l_theOther.m_side) );
        }
        return l_bRetVal;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/IApiEnum.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public interface IApiEnum {
	String getApiString();
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/MarketDataType.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class MarketDataType {
    // constants - market data types
    public static final int REALTIME   = 1;
    public static final int FROZEN     = 2;

    public static String getField( int marketDataType) {
        switch( marketDataType) {
            case REALTIME:                    return "Real-Time";
            case FROZEN:                      return "Frozen";

            default:                          return "Unknown";
        }
    }

    public static String[] getFields(){
    	int totalFields = MarketDataType.class.getFields().length;
    	String [] fields = new String[totalFields];
    	for (int i = 0; i < totalFields; i++){
    		fields[i] = MarketDataType.getField(i + 1);
    	}
    	return fields;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/Order.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.util.Vector;

public class Order {
    final public static int 	CUSTOMER = 0;
    final public static int 	FIRM = 1;
    final public static char    OPT_UNKNOWN='?';
    final public static char    OPT_BROKER_DEALER='b';
    final public static char    OPT_CUSTOMER ='c';
    final public static char    OPT_FIRM='f';
    final public static char    OPT_ISEMM='m';
    final public static char    OPT_FARMM='n';
    final public static char    OPT_SPECIALIST='y';
    final public static int 	AUCTION_MATCH = 1;
    final public static int 	AUCTION_IMPROVEMENT = 2;
    final public static int 	AUCTION_TRANSPARENT = 3;
    final public static String  EMPTY_STR = "";

    // main order fields
    public int 		m_orderId;
    public int 		m_clientId;
    public int  	m_permId;
    public String 	m_action;
    public int 		m_totalQuantity;
    public String 	m_orderType;
    public double 	m_lmtPrice;
    public double 	m_auxPrice;

    // extended order fields
    public String 	m_tif;  // "Time in Force" - DAY, GTC, etc.
    public String   m_activeStartTime; // GTC orders
    public String   m_activeStopTime; // GTC orders
    public String 	m_ocaGroup; // one cancels all group name
    public int      m_ocaType;  // 1 = CANCEL_WITH_BLOCK, 2 = REDUCE_WITH_BLOCK, 3 = REDUCE_NON_BLOCK
    public String 	m_orderRef;
    public boolean 	m_transmit;	// if false, order will be created but not transmited
    public int 		m_parentId;	// Parent order Id, to associate Auto STP or TRAIL orders with the original order.
    public boolean 	m_blockOrder;
    public boolean	m_sweepToFill;
    public int 		m_displaySize;
    public int 		m_triggerMethod; // 0=Default, 1=Double_Bid_Ask, 2=Last, 3=Double_Last, 4=Bid_Ask, 7=Last_or_Bid_Ask, 8=Mid-point
    public boolean 	m_outsideRth;
    public boolean  m_hidden;
    public String   m_goodAfterTime; // FORMAT: 20060505 08:00:00 {time zone}
    public String   m_goodTillDate;  // FORMAT: 20060505 08:00:00 {time zone}
    public boolean  m_overridePercentageConstraints;
    public String   m_rule80A;  // Individual = 'I', Agency = 'A', AgentOtherMember = 'W', IndividualPTIA = 'J', AgencyPTIA = 'U', AgentOtherMemberPTIA = 'M', IndividualPT = 'K', AgencyPT = 'Y', AgentOtherMemberPT = 'N'
    public boolean  m_allOrNone;
    public int      m_minQty;
    public double   m_percentOffset;    // REL orders only; specify the decimal, e.g. .04 not 4
    public double   m_trailStopPrice;   // for TRAILLIMIT orders only
    public double   m_trailingPercent;  // specify the percentage, e.g. 3, not .03

    // Financial advisors only
    public String   m_faGroup;
    public String   m_faProfile;
    public String   m_faMethod;
    public String   m_faPercentage;

    // Institutional orders only
    public String 	m_openClose;          // O=Open, C=Close
    public int 		m_origin;             // 0=Customer, 1=Firm
    public int      m_shortSaleSlot;      // 1 if you hold the shares, 2 if they will be delivered from elsewhere.  Only for Action="SSHORT
    public String   m_designatedLocation; // set when slot=2 only.
    public int      m_exemptCode;

    // SMART routing only
    public double   m_discretionaryAmt;
    public boolean  m_eTradeOnly;
    public boolean  m_firmQuoteOnly;
    public double   m_nbboPriceCap;
    public boolean  m_optOutSmartRouting;

    // BOX or VOL ORDERS ONLY
    public int      m_auctionStrategy; // 1=AUCTION_MATCH, 2=AUCTION_IMPROVEMENT, 3=AUCTION_TRANSPARENT

    // BOX ORDERS ONLY
    public double   m_startingPrice;
    public double   m_stockRefPrice;
    public double   m_delta;

    // pegged to stock or VOL orders
    public double   m_stockRangeLower;
    public double   m_stockRangeUpper;

    // VOLATILITY ORDERS ONLY
    public double   m_volatility;  // enter percentage not decimal, e.g. 2 not .02
    public int      m_volatilityType;     // 1=daily, 2=annual
    public int      m_continuousUpdate;
    public int      m_referencePriceType; // 1=Bid/Ask midpoint, 2 = BidOrAsk
    public String   m_deltaNeutralOrderType;
    public double   m_deltaNeutralAuxPrice;
    public int      m_deltaNeutralConId;
    public String   m_deltaNeutralSettlingFirm;
    public String   m_deltaNeutralClearingAccount;
    public String   m_deltaNeutralClearingIntent;
    public String   m_deltaNeutralOpenClose;
    public boolean  m_deltaNeutralShortSale;
    public int      m_deltaNeutralShortSaleSlot;
    public String   m_deltaNeutralDesignatedLocation;

    // COMBO ORDERS ONLY
    public double   m_basisPoints;      // EFP orders only, download only
    public int      m_basisPointsType;  // EFP orders only, download only

    // SCALE ORDERS ONLY
    public int      m_scaleInitLevelSize;
    public int      m_scaleSubsLevelSize;
    public double   m_scalePriceIncrement;
    public double   m_scalePriceAdjustValue;
    public int      m_scalePriceAdjustInterval;
    public double   m_scaleProfitOffset;
    public boolean  m_scaleAutoReset;
    public int      m_scaleInitPosition;
    public int      m_scaleInitFillQty;
    public boolean  m_scaleRandomPercent;
    public String   m_scaleTable;

    // HEDGE ORDERS ONLY
    public String   m_hedgeType; // 'D' - delta, 'B' - beta, 'F' - FX, 'P' - pair
    public String   m_hedgeParam; // beta value for beta hedge (in range 0-1), ratio for pair hedge

    // Clearing info
    public String 	m_account; // IB account
    public String   m_settlingFirm;
    public String   m_clearingAccount; // True beneficiary of the order
    public String   m_clearingIntent; // "" (Default), "IB", "Away", "PTA" (PostTrade)

    // ALGO ORDERS ONLY
    public String m_algoStrategy;
    public Vector<TagValue> m_algoParams;

    // What-if
    public boolean  m_whatIf;

    // Not Held
    public boolean  m_notHeld;

    // Smart combo routing params
    public Vector<TagValue> m_smartComboRoutingParams;

    // order combo legs
    public Vector<OrderComboLeg> m_orderComboLegs = new Vector<OrderComboLeg>();

    // order misc options
    public Vector<TagValue> m_orderMiscOptions;
    
    public Order() {
        m_lmtPrice = Double.MAX_VALUE;
        m_auxPrice = Double.MAX_VALUE;
        m_activeStartTime = EMPTY_STR;
        m_activeStopTime = EMPTY_STR;
    	m_outsideRth = false;
        m_openClose	= "O";
        m_origin = CUSTOMER;
        m_transmit = true;
        m_designatedLocation = EMPTY_STR;
        m_exemptCode = -1;
        m_minQty = Integer.MAX_VALUE;
        m_percentOffset = Double.MAX_VALUE;
        m_nbboPriceCap = Double.MAX_VALUE;
        m_optOutSmartRouting = false;
        m_startingPrice = Double.MAX_VALUE;
        m_stockRefPrice = Double.MAX_VALUE;
        m_delta = Double.MAX_VALUE;
        m_stockRangeLower = Double.MAX_VALUE;
        m_stockRangeUpper = Double.MAX_VALUE;
        m_volatility = Double.MAX_VALUE;
        m_volatilityType = Integer.MAX_VALUE;
        m_deltaNeutralOrderType = EMPTY_STR;
        m_deltaNeutralAuxPrice = Double.MAX_VALUE;
        m_deltaNeutralConId = 0;
        m_deltaNeutralSettlingFirm = EMPTY_STR;
        m_deltaNeutralClearingAccount = EMPTY_STR;
        m_deltaNeutralClearingIntent = EMPTY_STR;
        m_deltaNeutralOpenClose = EMPTY_STR;
        m_deltaNeutralShortSale = false;
        m_deltaNeutralShortSaleSlot = 0;
        m_deltaNeutralDesignatedLocation = EMPTY_STR;
        m_referencePriceType = Integer.MAX_VALUE;
        m_trailStopPrice = Double.MAX_VALUE;
        m_trailingPercent = Double.MAX_VALUE;
        m_basisPoints = Double.MAX_VALUE;
        m_basisPointsType = Integer.MAX_VALUE;
        m_scaleInitLevelSize = Integer.MAX_VALUE;
        m_scaleSubsLevelSize = Integer.MAX_VALUE;
        m_scalePriceIncrement = Double.MAX_VALUE;
        m_scalePriceAdjustValue = Double.MAX_VALUE;
        m_scalePriceAdjustInterval = Integer.MAX_VALUE;
        m_scaleProfitOffset = Double.MAX_VALUE;
        m_scaleAutoReset = false;
        m_scaleInitPosition = Integer.MAX_VALUE;
        m_scaleInitFillQty = Integer.MAX_VALUE;
        m_scaleRandomPercent = false;
        m_scaleTable = EMPTY_STR;
        m_whatIf = false;
        m_notHeld = false;
    }

    public boolean equals(Object p_other) {

        if ( this == p_other )
            return true;

        if ( p_other == null )
            return false;

        Order l_theOther = (Order)p_other;

        if ( m_permId == l_theOther.m_permId ) {
            return true;
        }

        if (m_orderId != l_theOther.m_orderId ||
        	m_clientId != l_theOther.m_clientId ||
        	m_totalQuantity != l_theOther.m_totalQuantity ||
        	m_lmtPrice != l_theOther.m_lmtPrice ||
        	m_auxPrice != l_theOther.m_auxPrice ||
        	m_ocaType != l_theOther.m_ocaType ||
        	m_transmit != l_theOther.m_transmit ||
        	m_parentId != l_theOther.m_parentId ||
        	m_blockOrder != l_theOther.m_blockOrder ||
        	m_sweepToFill != l_theOther.m_sweepToFill ||
        	m_displaySize != l_theOther.m_displaySize ||
        	m_triggerMethod != l_theOther.m_triggerMethod ||
        	m_outsideRth != l_theOther.m_outsideRth ||
        	m_hidden != l_theOther.m_hidden ||
        	m_overridePercentageConstraints != l_theOther.m_overridePercentageConstraints ||
        	m_allOrNone != l_theOther.m_allOrNone ||
        	m_minQty != l_theOther.m_minQty ||
        	m_percentOffset != l_theOther.m_percentOffset ||
        	m_trailStopPrice != l_theOther.m_trailStopPrice ||
        	m_trailingPercent != l_theOther.m_trailingPercent ||
        	m_origin != l_theOther.m_origin ||
        	m_shortSaleSlot != l_theOther.m_shortSaleSlot ||
        	m_discretionaryAmt != l_theOther.m_discretionaryAmt ||
        	m_eTradeOnly != l_theOther.m_eTradeOnly ||
        	m_firmQuoteOnly != l_theOther.m_firmQuoteOnly ||
        	m_nbboPriceCap != l_theOther.m_nbboPriceCap ||
        	m_optOutSmartRouting != l_theOther.m_optOutSmartRouting ||
        	m_auctionStrategy != l_theOther.m_auctionStrategy ||
        	m_startingPrice != l_theOther.m_startingPrice ||
        	m_stockRefPrice != l_theOther.m_stockRefPrice ||
        	m_delta != l_theOther.m_delta ||
        	m_stockRangeLower != l_theOther.m_stockRangeLower ||
        	m_stockRangeUpper != l_theOther.m_stockRangeUpper ||
        	m_volatility != l_theOther.m_volatility ||
        	m_volatilityType != l_theOther.m_volatilityType ||
        	m_continuousUpdate != l_theOther.m_continuousUpdate ||
        	m_referencePriceType != l_theOther.m_referencePriceType ||
        	m_deltaNeutralAuxPrice != l_theOther.m_deltaNeutralAuxPrice ||
        	m_deltaNeutralConId != l_theOther.m_deltaNeutralConId ||
        	m_deltaNeutralShortSale != l_theOther.m_deltaNeutralShortSale ||
        	m_deltaNeutralShortSaleSlot != l_theOther.m_deltaNeutralShortSaleSlot ||
        	m_basisPoints != l_theOther.m_basisPoints ||
        	m_basisPointsType != l_theOther.m_basisPointsType ||
        	m_scaleInitLevelSize != l_theOther.m_scaleInitLevelSize ||
        	m_scaleSubsLevelSize != l_theOther.m_scaleSubsLevelSize ||
        	m_scalePriceIncrement != l_theOther.m_scalePriceIncrement ||
        	m_scalePriceAdjustValue != l_theOther.m_scalePriceAdjustValue ||
        	m_scalePriceAdjustInterval != l_theOther.m_scalePriceAdjustInterval ||
        	m_scaleProfitOffset != l_theOther.m_scaleProfitOffset ||
        	m_scaleAutoReset != l_theOther.m_scaleAutoReset ||
        	m_scaleInitPosition != l_theOther.m_scaleInitPosition ||
        	m_scaleInitFillQty != l_theOther.m_scaleInitFillQty ||
        	m_scaleRandomPercent != l_theOther.m_scaleRandomPercent ||
        	m_whatIf != l_theOther.m_whatIf ||
        	m_notHeld != l_theOther.m_notHeld ||
        	m_exemptCode != l_theOther.m_exemptCode) {
        	return false;
        }

        if (Util.StringCompare(m_action, l_theOther.m_action) != 0 ||
        	Util.StringCompare(m_orderType, l_theOther.m_orderType) != 0 ||
        	Util.StringCompare(m_tif, l_theOther.m_tif) != 0 ||
        	Util.StringCompare(m_activeStartTime, l_theOther.m_activeStartTime) != 0 ||
        	Util.StringCompare(m_activeStopTime, l_theOther.m_activeStopTime) != 0 ||
        	Util.StringCompare(m_ocaGroup, l_theOther.m_ocaGroup) != 0 ||
        	Util.StringCompare(m_orderRef,l_theOther.m_orderRef) != 0 ||
        	Util.StringCompare(m_goodAfterTime, l_theOther.m_goodAfterTime) != 0 ||
        	Util.StringCompare(m_goodTillDate, l_theOther.m_goodTillDate) != 0 ||
        	Util.StringCompare(m_rule80A, l_theOther.m_rule80A) != 0 ||
        	Util.StringCompare(m_faGroup, l_theOther.m_faGroup) != 0 ||
        	Util.StringCompare(m_faProfile, l_theOther.m_faProfile) != 0 ||
        	Util.StringCompare(m_faMethod, l_theOther.m_faMethod) != 0 ||
        	Util.StringCompare(m_faPercentage, l_theOther.m_faPercentage) != 0 ||
        	Util.StringCompare(m_openClose, l_theOther.m_openClose) != 0 ||
        	Util.StringCompare(m_designatedLocation, l_theOther.m_designatedLocation) != 0 ||
        	Util.StringCompare(m_deltaNeutralOrderType, l_theOther.m_deltaNeutralOrderType) != 0 ||
        	Util.StringCompare(m_deltaNeutralSettlingFirm, l_theOther.m_deltaNeutralSettlingFirm) != 0 ||
        	Util.StringCompare(m_deltaNeutralClearingAccount, l_theOther.m_deltaNeutralClearingAccount) != 0 ||
        	Util.StringCompare(m_deltaNeutralClearingIntent, l_theOther.m_deltaNeutralClearingIntent) != 0 ||
        	Util.StringCompare(m_deltaNeutralOpenClose, l_theOther.m_deltaNeutralOpenClose) != 0 ||
        	Util.StringCompare(m_deltaNeutralDesignatedLocation, l_theOther.m_deltaNeutralDesignatedLocation) != 0 ||
        	Util.StringCompare(m_hedgeType, l_theOther.m_hedgeType) != 0 ||
        	Util.StringCompare(m_hedgeParam, l_theOther.m_hedgeParam) != 0 ||
        	Util.StringCompare(m_account, l_theOther.m_account) != 0 ||
        	Util.StringCompare(m_settlingFirm, l_theOther.m_settlingFirm) != 0 ||
        	Util.StringCompare(m_clearingAccount, l_theOther.m_clearingAccount) != 0 ||
        	Util.StringCompare(m_clearingIntent, l_theOther.m_clearingIntent) != 0 ||
        	Util.StringCompare(m_algoStrategy, l_theOther.m_algoStrategy) != 0 ||
        	Util.StringCompare(m_scaleTable, l_theOther.m_scaleTable) != 0) {
        	return false;
        }

        if (!Util.VectorEqualsUnordered(m_algoParams, l_theOther.m_algoParams)) {
        	return false;
        }

        if (!Util.VectorEqualsUnordered(m_smartComboRoutingParams, l_theOther.m_smartComboRoutingParams)) {
        	return false;
        }

    	// compare order combo legs
        if (!Util.VectorEqualsUnordered(m_orderComboLegs, l_theOther.m_orderComboLegs)) {
        	return false;
        }

        return true;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/OrderComboLeg.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;


public class OrderComboLeg {

    public double m_price; // price per leg

    public OrderComboLeg() {
        m_price = Double.MAX_VALUE;
    }

    public OrderComboLeg(double p_price) {
        m_price = p_price;
    }

    public boolean equals(Object p_other) {
        if ( this == p_other ) {
            return true;
        }
        else if ( p_other == null ) {
            return false;
        }

        OrderComboLeg l_theOther = (OrderComboLeg)p_other;

        if (m_price != l_theOther.m_price) {
        	return false;
        }

        return true;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/OrderState.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class OrderState {

	public String m_status;

	public String m_initMargin;
	public String m_maintMargin;
	public String m_equityWithLoan;

	public double m_commission;
	public double m_minCommission;
	public double m_maxCommission;
	public String m_commissionCurrency;

	public String m_warningText;

	OrderState() {
		this (null, null, null, null, 0.0, 0.0, 0.0, null, null);
	}

	OrderState(String status, String initMargin, String maintMargin,
			String equityWithLoan, double commission, double minCommission,
			double maxCommission, String commissionCurrency, String warningText) {

		m_initMargin = initMargin;
		m_maintMargin = maintMargin;
		m_equityWithLoan = equityWithLoan;
		m_commission = commission;
		m_minCommission = minCommission;
		m_maxCommission = maxCommission;
		m_commissionCurrency = commissionCurrency;
		m_warningText = warningText;
	}

	public boolean equals(Object other) {

        if (this == other)
            return true;

        if (other == null)
            return false;

        OrderState state = (OrderState)other;

        if (m_commission != state.m_commission ||
        	m_minCommission != state.m_minCommission ||
        	m_maxCommission != state.m_maxCommission) {
        	return false;
        }

        if (Util.StringCompare(m_status, state.m_status) != 0 ||
        	Util.StringCompare(m_initMargin, state.m_initMargin) != 0 ||
        	Util.StringCompare(m_maintMargin, state.m_maintMargin) != 0 ||
        	Util.StringCompare(m_equityWithLoan, state.m_equityWithLoan) != 0 ||
        	Util.StringCompare(m_commissionCurrency, state.m_commissionCurrency) != 0) {
        	return false;
        }

        return true;
	}
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/ScannerSubscription.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class ScannerSubscription {
    public final static int NO_ROW_NUMBER_SPECIFIED = -1;

    private int m_numberOfRows = NO_ROW_NUMBER_SPECIFIED;
    private String m_instrument;
    private String m_locationCode;
    private String m_scanCode;
    private double m_abovePrice = Double.MAX_VALUE;
    private double m_belowPrice = Double.MAX_VALUE;
    private int m_aboveVolume = Integer.MAX_VALUE;
    private int m_averageOptionVolumeAbove = Integer.MAX_VALUE;
    private double m_marketCapAbove = Double.MAX_VALUE;
    private double m_marketCapBelow = Double.MAX_VALUE;
    private String m_moodyRatingAbove;
    private String m_moodyRatingBelow;
    private String m_spRatingAbove;
    private String m_spRatingBelow;
    private String m_maturityDateAbove;
    private String m_maturityDateBelow;
    private double m_couponRateAbove = Double.MAX_VALUE;
    private double m_couponRateBelow = Double.MAX_VALUE;
    private String m_excludeConvertible;
    private String m_scannerSettingPairs;
    private String m_stockTypeFilter;

    // Get
    public int numberOfRows()                   { return m_numberOfRows; }
    public String instrument()                  { return m_instrument; }
    public String locationCode()                { return m_locationCode; }
    public String scanCode()                    { return m_scanCode; }
    public double abovePrice()                  { return m_abovePrice; }
    public double belowPrice()                  { return m_belowPrice; }
    public int aboveVolume()                    { return m_aboveVolume; }
    public int averageOptionVolumeAbove()       { return m_averageOptionVolumeAbove; }
    public double marketCapAbove()              { return m_marketCapAbove; }
    public double marketCapBelow()              { return m_marketCapBelow; }
    public String moodyRatingAbove()            { return m_moodyRatingAbove; }
    public String moodyRatingBelow()            { return m_moodyRatingBelow; }
    public String spRatingAbove()               { return m_spRatingAbove; }
    public String spRatingBelow()               { return m_spRatingBelow; }
    public String maturityDateAbove()           { return m_maturityDateAbove; }
    public String maturityDateBelow()           { return m_maturityDateBelow; }
    public double couponRateAbove()             { return m_couponRateAbove; }
    public double couponRateBelow()             { return m_couponRateBelow; }
    public String excludeConvertible()          { return m_excludeConvertible; }
    public String scannerSettingPairs()         { return m_scannerSettingPairs; }
    public String stockTypeFilter()             { return m_stockTypeFilter; }

    // Set
    public void numberOfRows(int num)          { m_numberOfRows = num; }
    public void instrument(String txt)         { m_instrument = txt; }
    public void locationCode(String txt)       { m_locationCode = txt; }
    public void scanCode(String txt)           { m_scanCode = txt; }
    public void abovePrice(double price)       { m_abovePrice = price; }
    public void belowPrice(double price)       { m_belowPrice = price; }
    public void aboveVolume(int volume)        { m_aboveVolume = volume; }
    public void averageOptionVolumeAbove(int volume) { m_averageOptionVolumeAbove = volume; }
    public void marketCapAbove(double cap)     { m_marketCapAbove = cap; }
    public void marketCapBelow(double cap)     { m_marketCapBelow = cap; }
    public void moodyRatingAbove(String r)     { m_moodyRatingAbove = r; }
    public void moodyRatingBelow(String r)     { m_moodyRatingBelow = r; }
    public void spRatingAbove(String r)        { m_spRatingAbove = r; }
    public void spRatingBelow(String r)        { m_spRatingBelow = r; }
    public void maturityDateAbove(String d)    { m_maturityDateAbove = d; }
    public void maturityDateBelow(String d)    { m_maturityDateBelow = d; }
    public void couponRateAbove(double r)      { m_couponRateAbove = r; }
    public void couponRateBelow(double r)      { m_couponRateBelow = r; }
    public void excludeConvertible(String c)   { m_excludeConvertible = c; }
    public void scannerSettingPairs(String val) { m_scannerSettingPairs = val; }
    public void stockTypeFilter(String val)    { m_stockTypeFilter = val; }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/TagValue.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class TagValue {

	public String m_tag;
	public String m_value;

	public TagValue() {
	}

	public TagValue(String p_tag, String p_value) {
		m_tag = p_tag;
		m_value = p_value;
	}

	public boolean equals(Object p_other) {

		if( this == p_other)
            return true;

        if( p_other == null)
            return false;

        TagValue l_theOther = (TagValue)p_other;

        if( Util.StringCompare(m_tag, l_theOther.m_tag) != 0 ||
        	Util.StringCompare(m_value, l_theOther.m_value) != 0) {
        	return false;
        }

		return true;
	}
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/TickType.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class TickType {
    // constants - tick types
    public static final int BID_SIZE   = 0;
    public static final int BID        = 1;
    public static final int ASK        = 2;
    public static final int ASK_SIZE   = 3;
    public static final int LAST       = 4;
    public static final int LAST_SIZE  = 5;
    public static final int HIGH       = 6;
    public static final int LOW        = 7;
    public static final int VOLUME     = 8;
    public static final int CLOSE      = 9;
    public static final int BID_OPTION = 10;
    public static final int ASK_OPTION = 11;
    public static final int LAST_OPTION = 12;
    public static final int MODEL_OPTION = 13;
    public static final int OPEN         = 14;
    public static final int LOW_13_WEEK  = 15;
    public static final int HIGH_13_WEEK = 16;
    public static final int LOW_26_WEEK  = 17;
    public static final int HIGH_26_WEEK = 18;
    public static final int LOW_52_WEEK  = 19;
    public static final int HIGH_52_WEEK = 20;
    public static final int AVG_VOLUME   = 21;
    public static final int OPEN_INTEREST = 22;
    public static final int OPTION_HISTORICAL_VOL = 23;
    public static final int OPTION_IMPLIED_VOL = 24;
    public static final int OPTION_BID_EXCH = 25;
    public static final int OPTION_ASK_EXCH = 26;
    public static final int OPTION_CALL_OPEN_INTEREST = 27;
    public static final int OPTION_PUT_OPEN_INTEREST = 28;
    public static final int OPTION_CALL_VOLUME = 29;
    public static final int OPTION_PUT_VOLUME = 30;
    public static final int INDEX_FUTURE_PREMIUM = 31;
    public static final int BID_EXCH = 32;
    public static final int ASK_EXCH = 33;
    public static final int AUCTION_VOLUME = 34;
    public static final int AUCTION_PRICE = 35;
    public static final int AUCTION_IMBALANCE = 36;
    public static final int MARK_PRICE = 37;
    public static final int BID_EFP_COMPUTATION  = 38;
    public static final int ASK_EFP_COMPUTATION  = 39;
    public static final int LAST_EFP_COMPUTATION = 40;
    public static final int OPEN_EFP_COMPUTATION = 41;
    public static final int HIGH_EFP_COMPUTATION = 42;
    public static final int LOW_EFP_COMPUTATION = 43;
    public static final int CLOSE_EFP_COMPUTATION = 44;
    public static final int LAST_TIMESTAMP = 45;
    public static final int SHORTABLE = 46;
    public static final int FUNDAMENTAL_RATIOS = 47;
    public static final int RT_VOLUME = 48;
    public static final int HALTED = 49;
    public static final int BID_YIELD = 50;
    public static final int ASK_YIELD = 51;
    public static final int LAST_YIELD = 52;
    public static final int CUST_OPTION_COMPUTATION = 53;
    public static final int TRADE_COUNT = 54;
    public static final int TRADE_RATE = 55;
    public static final int VOLUME_RATE = 56;
    public static final int LAST_RTH_TRADE = 57;
    public static final int REGULATORY_IMBALANCE = 61;

    public static String getField( int tickType) {
        switch( tickType) {
            case BID_SIZE:                    return "bidSize";
            case BID:                         return "bidPrice";
            case ASK:                         return "askPrice";
            case ASK_SIZE:                    return "askSize";
            case LAST:                        return "lastPrice";
            case LAST_SIZE:                   return "lastSize";
            case HIGH:                        return "high";
            case LOW:                         return "low";
            case VOLUME:                      return "volume";
            case CLOSE:                       return "close";
            case BID_OPTION:                  return "bidOptComp";
            case ASK_OPTION:                  return "askOptComp";
            case LAST_OPTION:                 return "lastOptComp";
            case MODEL_OPTION:                return "modelOptComp";
            case OPEN:                        return "open";
            case LOW_13_WEEK:                 return "13WeekLow";
            case HIGH_13_WEEK:                return "13WeekHigh";
            case LOW_26_WEEK:                 return "26WeekLow";
            case HIGH_26_WEEK:                return "26WeekHigh";
            case LOW_52_WEEK:                 return "52WeekLow";
            case HIGH_52_WEEK:                return "52WeekHigh";
            case AVG_VOLUME:                  return "AvgVolume";
            case OPEN_INTEREST:               return "OpenInterest";
            case OPTION_HISTORICAL_VOL:       return "OptionHistoricalVolatility";
            case OPTION_IMPLIED_VOL:          return "OptionImpliedVolatility";
            case OPTION_BID_EXCH:             return "OptionBidExchStr";
            case OPTION_ASK_EXCH:             return "OptionAskExchStr";
            case OPTION_CALL_OPEN_INTEREST:   return "OptionCallOpenInterest";
            case OPTION_PUT_OPEN_INTEREST:    return "OptionPutOpenInterest";
            case OPTION_CALL_VOLUME:          return "OptionCallVolume";
            case OPTION_PUT_VOLUME:           return "OptionPutVolume";
            case INDEX_FUTURE_PREMIUM:        return "IndexFuturePremium";
            case BID_EXCH:                    return "bidExch";
            case ASK_EXCH:                    return "askExch";
            case AUCTION_VOLUME:              return "auctionVolume";
            case AUCTION_PRICE:               return "auctionPrice";
            case AUCTION_IMBALANCE:           return "auctionImbalance";
            case MARK_PRICE:                  return "markPrice";
            case BID_EFP_COMPUTATION:         return "bidEFP";
            case ASK_EFP_COMPUTATION:         return "askEFP";
            case LAST_EFP_COMPUTATION:        return "lastEFP";
            case OPEN_EFP_COMPUTATION:        return "openEFP";
            case HIGH_EFP_COMPUTATION:        return "highEFP";
            case LOW_EFP_COMPUTATION:         return "lowEFP";
            case CLOSE_EFP_COMPUTATION:       return "closeEFP";
            case LAST_TIMESTAMP:              return "lastTimestamp";
            case SHORTABLE:                   return "shortable";
            case FUNDAMENTAL_RATIOS:          return "fundamentals";
            case RT_VOLUME:                   return "RTVolume";
            case HALTED:                      return "halted";
            case BID_YIELD:                   return "bidYield";
            case ASK_YIELD:                   return "askYield";
            case LAST_YIELD:                  return "lastYield";
            case CUST_OPTION_COMPUTATION:     return "custOptComp";
            case TRADE_COUNT:                 return "trades";
            case TRADE_RATE:                  return "trades/min";
            case VOLUME_RATE:                 return "volume/min";
            case LAST_RTH_TRADE:              return "lastRTHTrade";
            case REGULATORY_IMBALANCE:        return "regulatoryImbalance";
            default:                          return "unknown";
        }
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/UnderComp.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

public class UnderComp {

	public int    m_conId;
	public double m_delta;
	public double m_price;

	public UnderComp() {
		m_conId = 0;
		m_delta = 0;
		m_price = 0;
	}

    public boolean equals(Object p_other) {

    	if (this == p_other) {
    		return true;
    	}

    	if (p_other == null || !(p_other instanceof UnderComp)) {
    		return false;
    	}

        UnderComp l_theOther = (UnderComp)p_other;

        if (m_conId != l_theOther.m_conId) {
        	return false;
        }
        if (m_delta != l_theOther.m_delta) {
        	return false;
        }
        if (m_price != l_theOther.m_price) {
        	return false;
        }

        return true;
    }
}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/Util.java
/* Copyright (C) 2013 Interactive Brokers LLC. All rights reserved.  This code is subject to the terms
 * and conditions of the IB API Non-Commercial License or the IB API Commercial License, as applicable. */

package com.ib.client;

import java.util.Vector;

public class Util {

	public static boolean StringIsEmpty(String str) {
		return str == null || str.length() == 0;
	}

    public static String NormalizeString(String str) {
    	return str != null ? str : "";
    }

    public static int StringCompare(String lhs, String rhs) {
    	return NormalizeString(lhs).compareTo(NormalizeString(rhs));
    }

    public static int StringCompareIgnCase(String lhs, String rhs) {
    	return NormalizeString(lhs).compareToIgnoreCase(NormalizeString(rhs));
    }

    public static boolean VectorEqualsUnordered(Vector lhs, Vector rhs) {

    	if (lhs == rhs)
    		return true;

    	int lhsCount = lhs == null ? 0 : lhs.size();
    	int rhsCount = rhs == null ? 0 : rhs.size();

    	if (lhsCount != rhsCount)
    		return false;

    	if (lhsCount == 0)
    		return true;

    	boolean[] matchedRhsElems = new boolean[rhsCount];

    	for (int lhsIdx = 0; lhsIdx < lhsCount; ++lhsIdx) {
    		Object lhsElem = lhs.get(lhsIdx);
    		int rhsIdx = 0;
    		for (; rhsIdx < rhsCount; ++rhsIdx) {
    			if (matchedRhsElems[rhsIdx]) {
    				continue;
    			}
    			if (lhsElem.equals(rhs.get(rhsIdx))) {
    				matchedRhsElems[rhsIdx] = true;
    				break;
    			}
    		}
    		if (rhsIdx >= rhsCount) {
    			// no matching elem found
    			return false;
    		}
    	}

    	return true;
    }

    public static String IntMaxString(int value) {
    	return (value == Integer.MAX_VALUE) ? "" : "" + value;
    }

    public static String DoubleMaxString(double value) {
    	return (value == Double.MAX_VALUE) ? "" : "" + value;
    }

}
/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/client_test.sh
FILES=/Users/Kundjanasith/Documents/workspace/TWS_API/src/com/ib/client/*
for i in $FILES
do
  echo $i
  echo $i >> client_test.txt
  cat $i >> client_test.txt
done
